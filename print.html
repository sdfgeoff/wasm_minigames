<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>wasm_games_in_rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what_its_all_about.html"><strong aria-hidden="true">1.</strong> What It's All About</a></li><li class="chapter-item expanded "><a href="the_basics.html"><strong aria-hidden="true">2.</strong> The Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building_and_loading_wasm/index.html"><strong aria-hidden="true">2.1.</strong> Building and loading WASM</a></li><li class="chapter-item expanded "><a href="cancel_load_animation/index.html"><strong aria-hidden="true">2.2.</strong> Cancel the load animation</a></li><li class="chapter-item expanded "><a href="binding_events/index.html"><strong aria-hidden="true">2.3.</strong> Binding Events</a></li><li class="chapter-item expanded "><a href="a_first_shader/index.html"><strong aria-hidden="true">2.4.</strong> A First Shader</a></li><li class="chapter-item expanded "><a href="fixing_resolution/index.html"><strong aria-hidden="true">2.5.</strong> Fixing the Resolution</a></li><li class="chapter-item expanded "><a href="passing_in_uniforms/index.html"><strong aria-hidden="true">2.6.</strong> Passing in Uniforms</a></li><li class="chapter-item expanded "><a href="binding_textures/index.html"><strong aria-hidden="true">2.7.</strong> Binding Textures</a></li></ol></li><li class="chapter-item expanded "><a href="a_first_game_swoop.html"><strong aria-hidden="true">3.</strong> A First Game: Swoop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="swoop_drawing_the_player/index.html"><strong aria-hidden="true">3.1.</strong> Drawing The Player Ship</a></li><li class="chapter-item expanded "><a href="swoop_drawing_the_map/index.html"><strong aria-hidden="true">3.2.</strong> Drawing The Map</a></li><li class="chapter-item expanded "><a href="swoop_ship_motion_physics/index.html"><strong aria-hidden="true">3.3.</strong> Ship Motion Physics</a></li><li class="chapter-item expanded "><a href="swoop_ship_keyboard_input/index.html"><strong aria-hidden="true">3.4.</strong> Keyboard Input</a></li><li class="chapter-item expanded "><a href="swoop_ship_collision_physics/index.html"><strong aria-hidden="true">3.5.</strong> Ship Collision Physics</a></li><li class="chapter-item expanded "><a href="swoop_ship_spawn_points/index.html"><strong aria-hidden="true">3.6.</strong> Ship Spawn Points</a></li><li class="chapter-item expanded "><a href="swoop_map_generation/index.html"><strong aria-hidden="true">3.7.</strong> Map Generation</a></li><li class="chapter-item expanded "><a href="swoop_camera_positioning/index.html"><strong aria-hidden="true">3.8.</strong> Camera Positioning</a></li><li class="chapter-item expanded "><a href="swoop_enemy_racers/index.html"><strong aria-hidden="true">3.9.</strong> Enemy Racers</a></li><li class="chapter-item expanded "><a href="swoop_engine_trails/index.html"><strong aria-hidden="true">3.10.</strong> Engine Trails</a></li><li class="chapter-item expanded "><a href="swoop_wingtip_trails/index.html"><strong aria-hidden="true">3.11.</strong> Wingtip Trails and Optimizations</a></li><li class="chapter-item expanded "><a href="swoop_start_sequence/index.html"><strong aria-hidden="true">3.12.</strong> Start Sequence and Fonts</a></li><li class="chapter-item expanded "><a href="swoop_counting_laps/index.html"><strong aria-hidden="true">3.13.</strong> Counting Laps</a></li><li class="chapter-item expanded "><a href="swoop_win_condition/index.html"><strong aria-hidden="true">3.14.</strong> Win Condition</a></li></ol></li><li class="chapter-item expanded "><a href="stl_viewer.html"><strong aria-hidden="true">4.</strong> STL Viewer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stl_viewer_load_stl/index.html"><strong aria-hidden="true">4.1.</strong> Load and Render STL Files</a></li><li class="chapter-item expanded "><a href="stl_viewer_camera_lookaround/index.html"><strong aria-hidden="true">4.2.</strong> Camera Lookaround</a></li><li class="chapter-item expanded "><a href="stl_viewer_background/index.html"><strong aria-hidden="true">4.3.</strong> Background and Appearance</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">wasm_games_in_rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-its-all-about" id="what-its-all-about">What It's All About</a></h1>
<p>Game engines are huge behemoths, and contain algorithms for handling everything
and the kitchen sink. While that's normally good, if you want to do something
small, or possibly do something outside the bounds of a normal game enine,
you suddenly have to learn how to do everything yourself.</p>
<p>Or perhaps you just like the &quot;type it and run&quot; style of development for
shadertoy shaders and want something similar that you can host on your system
as (pretty much) a single file.</p>
<p>Either way, this book chronicles my adventures into creating WASM games from
scratch in Rust.
All the code is available on <a href="https://github.com/sdfgeoff/wasm_minigames">github</a>.</p>
<h1><a class="header" href="#the-basics" id="the-basics">The Basics</a></h1>
<p>First we'll have a look at the basics of WASM and WebGL, we'll get
events from the browser, we'll draw things to the screen. All the
requirements for creating a game.</p>
<p>Ready?</p>
<p>Lets go.</p>
<h1><a class="header" href="#building-and-loading-wasm" id="building-and-loading-wasm">Building and loading WASM</a></h1>
<p>WASM builds have some requirements. For example, you need to define the library
type as <code>cdylib</code>.</p>
<p>It's probably easiest to look at a working Cargo.toml:</p>
<pre><code class="language-toml">[package]
name = &quot;building_and_loading_wasm&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Geoffrey Irons &lt;sdfgeoff@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
wasm-bindgen=&quot;0.2.63&quot;
js-sys=&quot;0.3.40&quot;

[dependencies.web-sys]
version = &quot;0.3.4&quot;
features = []
</code></pre>
<p>Rust has a great tool called <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a> which makes the process of building
and deploying WASM code nice and simple. It's designed to work with bundlers,
but to avoid the gigabyte of dependencies that webpack pulls in, I decided to
go for the simplest output type: &quot;web&quot;.</p>
<p>My invocation of <code>wasm-pack</code> is:</p>
<pre><code class="language-shell">wasm-pack build --out-dir $(OUT_DIR) --target web --dev
# OR
wasm-pack build --out-dir $(OUT_DIR) --target web --release
</code></pre>
<p>When invoked, this will create a bunch of files: <code>core_bg.wasm</code>, <code>core.js</code>, <code>core_bg.d.ts</code>, <code>core.d.ts</code> and <code>package.json</code>.
The only files we need are <code>core_bg.wasm</code> (the actual webassembly) and <code>core.js</code> (code that loads the WASM).</p>
<p>Now you need to load it from HTML/js. For all the examples in this book, loading
is an invocation of the function:</p>
<pre><code class="language-javascript">&quot;use strict&quot;

function load(canvas, module_path, options) {
    console.log(&quot;Loading&quot;, module_path)
    canvas.className = &quot;loading&quot;
    
    import(module_path)
    .then((module) =&gt; {
        module.default().then(function(obj){
            let core = new module.Core(canvas.id, options)
            core.start()
            canvas.core = core
        }).catch(function(e){
            console.error(&quot;Failed to init module:&quot;, e)
            canvas.className = &quot;error&quot;
        })
    }).catch(function(e) {
        console.error(&quot;Failed to load:&quot;, e)
        canvas.className = &quot;error&quot;
    });
}

function setup_canvas() {
    const canvases = document.querySelectorAll(&quot;canvas&quot;);
    for (let canvas of canvases) {
        let options = canvas.getAttribute(&quot;options&quot;) || &quot;&quot;
        let id = canvas.id.split(&quot;-&quot;)[0] // So we can have multiple canvas' with the same app and different options
        let module_path = './' + id + '/pkg/'+ id +'.js' // Path to WASM JS bindings
        canvas.tabIndex = 1
        canvas.addEventListener(&quot;click&quot;, function() {
            load(canvas, module_path, options)
        }, {'once':true})
    }
}
setup_canvas()

</code></pre>
<p>using an element like:</p>
<pre><code class="language-html">&lt;canvas id=&quot;building_and_loading_wasm&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>A very simple rust webassembly program looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::wasm_bindgen;

// Pull in the console.log function so we can debug things more easily
#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

// This struct will be accessible from JS as a JS object that can be
// created using `new Core()`
#[wasm_bindgen]
pub struct Core {}

#[wasm_bindgen]
impl Core {
    #[wasm_bindgen(constructor)]
    pub fn new(canvas_id: String) -&gt; Self {
        log(&amp;format!(&quot;WASM Started for canvas {}&quot;, canvas_id));
        Self {}
    }

    #[wasm_bindgen]
    pub fn start(&amp;mut self) {
        log(&quot;App Started&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>All up this creates:</p>
<p><canvas id="building_and_loading_wasm"></canvas></p>
<p>You'll notice when you click on it plays a loading animation. That's done in
in CSS. Normally this would get cancelled from inside the WASM binary, but
this example doesn't.</p>
<p>To check if this example is working, you have to look at the browser console.
You should see something like:</p>
<pre><code>Loading ../games/trivial/core.js
WASM Started for canvas trivial
App Started
</code></pre>
<p>The first message comes from the javascript. The other two come from the WASM.
The message will only appear once, as the javascript prevents the WAS loading
twice.</p>
<h1><a class="header" href="#cancel-the-load-animation" id="cancel-the-load-animation">Cancel the load animation</a></h1>
<p>On this page, when clicking on a canvas, it sets the css style to &quot;loading&quot;
which creates a load animation. To stop the load animation, the webassembly
needs to change the classname of the canvas to &quot;loaded&quot; rather than &quot;loading&quot;.
To do this we need to access the DOM.</p>
<p>You may have noticed that in the rust on the previous page the ID of the
canvas gets passed in. This allows us to find the element on the page.</p>
<p>In JS we would use <code>document.getElementById(id)</code>. For some reason this doesn't
exist in web-sys, so instead we can use <code>document.query_selector</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let window = window().unwrap();
let document = window.document().unwrap();
let element = document
    .query_selector(&amp;selector)
    .expect(&quot;Call failed&quot;)
    .expect(&quot;No element with selector&quot;);

element.set_class_name(&quot;loaded&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>There's a fair bit of unwrap/expecting going on there, and it isn't ideal.
However, I'm not sure there really is any good way for the program to handle
the place where it's trying to draw not existing, so it will do for now.</p>
<p>To get this code to compile, you need a bunch of things:</p>
<p>In your Cargo.toml you need a bunch of features from the web-sys crate:</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3.4&quot;
features = [
    &quot;Document&quot;,
    &quot;HtmlCanvasElement&quot;,
    &quot;HtmlElement&quot;,
    &quot;Window&quot;,
]
</code></pre>
<p>We're using those API's, so it all makes sense. There's also the <code>dyn_into</code>
thing, which is in <code>wasm_bindgen::JsCast;</code>. This allows casting from a generic
<code>HTMLElement</code> into a <code>HtmlCanvasElement</code>.</p>
<p>The result:</p>
<p><canvas id="cancel_load_animation"></canvas></p>
<p>When you click it, it goes black - the contents of the <code>loaded</code> style</p>
<h1><a class="header" href="#binding-events" id="binding-events">Binding Events</a></h1>
<p>To make a game you need to have input from the user such as the keyboard and
mouse. You also need to have a mainloop (or some other way to update what the
user see's). In a browser, these are emitted as
<a href="https://developer.mozilla.org/en-US/docs/Web/Events">events</a> and updating
your program can be done using
<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame()</a></p>
<p>First lets deal with <code>requestAnimationFrame</code>. There's an example <a href="https://rustwasm.github.io/wasm-bindgen/examples/request-animation-frame.html">on the
wasm-bindgen site</a>
which in theory makes this a copy-paste exercise.</p>
<p>In practice I didn't manage to get <code>request_animation_frame</code> to be able to
invoke a function on the <code>Core</code> struct. The issue is that you have to have
multiple references to the Core struct (so you can invoke
request_animation_frame again) so you need to put it in a <code>Rc</code>. However you
can't return the <code>Rc</code> from the constructor. As a result, I decided that the
<code>Core</code> struct would create an <code>App</code> struct. The <code>App</code> struct looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct App {
    canvas: HtmlCanvasElement,
}

impl App {
    pub fn new(canvas: HtmlCanvasElement) -&gt; Self {
        Self { canvas }
    }

    pub fn animation_frame(&amp;mut self) {
        log(&quot;Animation Frame&quot;)
    }

    pub fn mouse_event(&amp;mut self, event: MouseEvent) {
        log(&amp;format!(&quot;Mouse Event {:?}&quot;, event));
    }
    pub fn key_event(&amp;mut self, event: KeyEvent) {
        log(&amp;format!(&quot;Key Event {:?}&quot;, event));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where Event is a custom enum that I'll populate with the events that the
application cares about (eg Mouse/Keyboard/Resize).</p>
<p>Then binding the animation_frame looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_callback(closure: &amp;Closure&lt;dyn FnMut()&gt;) -&gt; &amp;Function {
    return closure.as_ref().unchecked_ref()
}

&lt;&lt; snip &gt;&gt;

let callback = Rc::new(RefCell::new(None));

let anim_app = self.app.clone();
let anim_window = window.clone();
let anim_callback = callback.clone();

*callback.borrow_mut() = Some(Closure::wrap(Box::new(move || {
    anim_app.borrow_mut().animation_frame();
    // Schedule ourself for another requestAnimationFrame callback.
    anim_window
        .request_animation_frame(make_callback(anim_callback.borrow().as_ref().unwrap()));
}) as Box&lt;dyn FnMut()&gt;));
window.request_animation_frame(make_callback(callback.borrow().as_ref().unwrap()));
<span class="boring">}
</span></code></pre></pre>
<p>I will happily admit I'm 100% sure about everything going on in here. I haven't
figured out trait objects yet.</p>
<p>Fortunately, handling the other key and mouse is a bit easier because they aren't recursive:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let anim_app = self.app.clone();

let callback = Closure::wrap(Box::new(move |event: web_sys::MouseEvent| {
    anim_app.borrow_mut().mouse_event(event);
}) as Box&lt;dyn FnMut(_)&gt;);

let callback_ref = callback.as_ref().unchecked_ref();
self.canvas.add_event_listener_with_callback(&quot;mousedown&quot;, callback_ref).unwrap();
self.canvas.add_event_listener_with_callback(&quot;mouseup&quot;, callback_ref).unwrap();
self.canvas.add_event_listener_with_callback(&quot;mousemove&quot;, callback_ref).unwrap();
self.canvas.add_event_listener_with_callback(&quot;mouseenter&quot;, callback_ref).unwrap();
self.canvas.add_event_listener_with_callback(&quot;mouseleave&quot;, callback_ref).unwrap();
self.canvas.add_event_listener_with_callback(&quot;mouseover&quot;, callback_ref).unwrap();

callback.forget();
<span class="boring">}
</span></code></pre></pre>
<p>There were a bunch of gotchas with key events. For some reason, key events only
fire for canvas' when they have a tabindex and the canvas is focused. I wasted
a good hour or two on this thinking that mdbook was gobbling the input with its
document-level event handler....</p>
<p>Another gotcha with key events is that we need to stop the browser respoding to
them. This is easy enough with <code>e.stop_propagation()</code> and <code>e.prevent_default()</code>
which both prevent other handlers on the page and the browser from seeing the
event.</p>
<p><canvas id="binding_events"></canvas></p>
<p>Once again there's nothing visible, but if you check the console you'll see all
the events reported by the WASM</p>
<h1><a class="header" href="#a-first-shader" id="a-first-shader">A First Shader</a></h1>
<p>Now that we can get input into our game, it's time to display output
for the user. We'll be using 
<a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/">WebGL2</a>.</p>
<p>Mozilla provides a great bunch of tutorials on webgl, the first of which is
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">here</a>
This (and the next few pages) are heavily based on these tutorials.</p>
<p>A HTML canvas con be a whole bunch of things, only one of which is
webgl. As a result, we have to specifically fetch webgl2 from the canvas:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_gl_context(canvas: &amp;HtmlCanvasElement) -&gt; Result&lt;WebGl2RenderingContext, JsValue&gt; {
    Ok(canvas.get_context(&quot;webgl2&quot;)?.unwrap().dyn_into()?)
}
<span class="boring">}
</span></code></pre></pre>
<p>That's the easy part. From their to the first triangle is quite a long
way. The reason it is so complex is because it is a complex thing. We
need to:</p>
<ol>
<li>Provide a matching vertex and fragment shader (that compile with no errors)</li>
<li>Provide a bunch of vertices for the shader to operate on</li>
</ol>
<p>Porting from the Mozilla tutorials wasn't too hard, but:</p>
<ol>
<li>Because Rust is amazing, you have to in a bunch of error checking for JS errors</li>
<li>I stripped out all the uniforms for now to make this example simpler</li>
<li>Because Rust doesn't seem to have the mat4 object, I removed the perspective matrix projection from the vertex shader</li>
</ol>
<p>After that, we have:</p>
<p><canvas id="a_first_shader"></canvas></p>
<p>A triangle!</p>
<p>Most of the ported code for is in the file <code>triangle.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::{JsCast, JsValue};
use web_sys::{WebGl2RenderingContext, WebGlBuffer, WebGlProgram, WebGlShader};

/// An error to represent problems with a shader.
#[derive(Debug)]
pub enum ShaderError {
    /// Call to gl.create_shader returned null
    ShaderAllocError,

    /// Call to create_program returned null
    ShaderProgramAllocError,

    ShaderCompileError {
        shader_type: u32,
        compiler_output: String,
    },
    /// Failed to receive error information about why the shader failed to compile
    /// Generally this is indicative of trying to get the error when one hasn't occured
    ShaderGetInfoError,

    /// I think this means that the Vertex and Fragment shaders incompatible
    ShaderLinkError(),
}

/// An error with this whole object.
#[derive(Debug)]
pub enum TriangleError {
    /// Failed to upload buffer data to the GPU
    BufferCreationFailed,

    /// An unhandled/unspecified error
    JsError(JsValue),

    /// Something wrong with the shader
    ShaderError(ShaderError),
}

impl From&lt;JsValue&gt; for TriangleError {
    fn from(err: JsValue) -&gt; TriangleError {
        TriangleError::JsError(err)
    }
}

impl From&lt;ShaderError&gt; for TriangleError {
    fn from(err: ShaderError) -&gt; TriangleError {
        TriangleError::ShaderError(err)
    }
}

pub struct FirstTriangle {
    position_buffer: WebGlBuffer,
    program: WebGlProgram,
    attrib_vertex_positions: u32,
}

impl FirstTriangle {
    pub fn new(gl: &amp;WebGl2RenderingContext) -&gt; Result&lt;Self, TriangleError&gt; {
        let position_buffer = upload_array_f32(gl, vec![-1.0, 1.0, 1.0, 1.0, 0.0, -1.0])?;

        let program = init_shader_program(
            gl,
            include_str!(&quot;resources/shader.vert&quot;),
            include_str!(&quot;resources/shader.frag&quot;),
        )?;

        let attrib_vertex_positions = gl.get_attrib_location(&amp;program, &quot;aVertexPosition&quot;) as u32;

        Ok(Self {
            position_buffer,
            program,
            attrib_vertex_positions,
        })
    }

    pub fn render(&amp;mut self, gl: &amp;WebGl2RenderingContext) {
        gl.use_program(Some(&amp;self.program));

        gl.bind_buffer(
            WebGl2RenderingContext::ARRAY_BUFFER,
            Some(&amp;self.position_buffer),
        );

        gl.vertex_attrib_pointer_with_i32(
            self.attrib_vertex_positions,
            2, // num components
            WebGl2RenderingContext::FLOAT,
            false, // normalize
            0,     // stride
            0,     // offset
        );
        gl.enable_vertex_attrib_array(self.attrib_vertex_positions);

        gl.draw_arrays(
            WebGl2RenderingContext::TRIANGLE_STRIP,
            0, //offset,
            3, // vertex count
        );
    }
}

fn upload_array_f32(
    gl: &amp;WebGl2RenderingContext,
    vertices: Vec&lt;f32&gt;,
) -&gt; Result&lt;WebGlBuffer, TriangleError&gt; {
    let position_buffer = gl
        .create_buffer()
        .ok_or(TriangleError::BufferCreationFailed)?;

    gl.bind_buffer(WebGl2RenderingContext::ARRAY_BUFFER, Some(&amp;position_buffer));

    let memory_buffer = wasm_bindgen::memory()
        .dyn_into::&lt;js_sys::WebAssembly::Memory&gt;()?
        .buffer();

    let vertices_location = vertices.as_ptr() as u32 / 4;

    let vert_array = js_sys::Float32Array::new(&amp;memory_buffer)
        .subarray(vertices_location, vertices_location + vertices.len() as u32);

    gl.buffer_data_with_array_buffer_view(
        WebGl2RenderingContext::ARRAY_BUFFER,
        &amp;vert_array,
        WebGl2RenderingContext::STATIC_DRAW,
    );

    Ok(position_buffer)
}

fn load_shader(
    gl: &amp;WebGl2RenderingContext,
    shader_type: u32,
    shader_text: &amp;str,
) -&gt; Result&lt;WebGlShader, ShaderError&gt; {
    let shader = gl
        .create_shader(shader_type)
        .ok_or(ShaderError::ShaderAllocError)?;
    gl.shader_source(&amp;shader, shader_text);
    gl.compile_shader(&amp;shader);
    if !gl
        .get_shader_parameter(&amp;shader, WebGl2RenderingContext::COMPILE_STATUS)
        .is_truthy()
    {
        let compiler_output = &amp;gl
            .get_shader_info_log(&amp;shader)
            .ok_or(ShaderError::ShaderGetInfoError)?;
        gl.delete_shader(Some(&amp;shader));
        return Err(ShaderError::ShaderCompileError {
            shader_type,
            compiler_output: compiler_output.to_string(),
        });
    }
    Ok(shader)
}

pub fn init_shader_program(
    gl: &amp;WebGl2RenderingContext,
    vert_source: &amp;str,
    frag_source: &amp;str,
) -&gt; Result&lt;WebGlProgram, ShaderError&gt; {
    let vert_shader = load_shader(gl, WebGl2RenderingContext::VERTEX_SHADER, vert_source)?;
    let frag_shader = load_shader(gl, WebGl2RenderingContext::FRAGMENT_SHADER, frag_source)?;

    let shader_program = gl
        .create_program()
        .ok_or(ShaderError::ShaderProgramAllocError)?;
    gl.attach_shader(&amp;shader_program, &amp;vert_shader);
    gl.attach_shader(&amp;shader_program, &amp;frag_shader);

    gl.link_program(&amp;shader_program);

    if !(gl.get_program_parameter(&amp;shader_program, WebGl2RenderingContext::LINK_STATUS)).is_truthy()
    {
        gl.delete_program(Some(&amp;shader_program));
        gl.delete_shader(Some(&amp;vert_shader));
        gl.delete_shader(Some(&amp;frag_shader));
        return Err(ShaderError::ShaderLinkError());
    }

    Ok(shader_program)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#fixing-the-resolution" id="fixing-the-resolution">Fixing the Resolution</a></h1>
<p>We have sucessfully rendered a triangle with a shader, however it's kind-of
blurry. This is because the resolution of the buffer that the webgl is rendering
does not match the resolution of the image in the browser.</p>
<p>We need to have some code that figures out what size the canvas output is, and
makes sure that the webgl has that as it's output resolution.</p>
<p>Easy enough:</p>
<pre><code>    fn check_resize(&amp;mut self) {
        let client_width = self.canvas.client_width();
        let client_height = self.canvas.client_height();
        let canvas_width = self.canvas.width() as i32;
        let canvas_height = self.canvas.height() as i32;
        
        if client_width != canvas_width || client_height != canvas_height {
            self.canvas.set_width(client_width as u32);
            self.canvas.set_height(client_height as u32);
            self.gl
                .viewport(0, 0, client_width, client_height);
            log(&amp;format!(&quot;Resized to {}:{}&quot;, client_width, client_height));
        }
    }
</code></pre>
<p>I ran this inside the <code>updateAnimationFrame</code> loop. This probably isn't ideal
because it involves sending/receiving data bewteen WASM and JS lots of times
per second. Unfortunately there isn't an &quot;onresize&quot; event that works for
generic elements. This could be run just when the canvas initalizes, but then
it won't catch the user zooming.</p>
<p><canvas id="fixing_resolution"></canvas></p>
<h1><a class="header" href="#passing-in-uniforms" id="passing-in-uniforms">Passing In Uniforms</a></h1>
<p>Uniforms are used to control a shader while it is running. They can pass in
data such as object transforms, the time, the screen resolution or anything
else really.</p>
<p>There are two parts to passing in a uniform:</p>
<ol>
<li>Finding where the uniform is using <code>gl.get_uniform_location(&amp;program, name)</code></li>
<li><em>When the program is active</em> setting the value of the uniform using <code>gl.uniform*</code> to set the value.</li>
</ol>
<p>I've also changed the triangle to being a single full-screen quad. This means
we can now do fancy pixel-shader-rendering:
<canvas id="passing_in_uniforms"></canvas></p>
<p>Yes that's a single quad. The Shader is <a href="https://www.shadertoy.com/view/tt2XzG">taken from
shadertoy</a>, written <a href="https://www.iquilezles.org/">by
&quot;iq&quot;</a> and used under CC-BY-NC-SA 3.0.</p>
<p>For this I passed in a floating point number for time, and a float vec2 for
resolution: </p>
<pre><code>let uniform_resolution = gl.get_uniform_location(&amp;program, &quot;iResolution&quot;);
let uniform_time = gl.get_uniform_location(&amp;program, &quot;iTime&quot;);

&lt;&lt; snip &gt;&gt;

gl.use_program(Some(&amp;self.program));

gl.uniform1f(self.uniform_time.as_ref(), self.time);
gl.uniform2f(
    self.uniform_resolution.as_ref(),
    self.resolution.0 as f32,
    self.resolution.1 as f32,
);
</code></pre>
<p>There are some gotcha's. The uniform name has to exist in the shader and be used.
So if you have the a shader that declares <code>uniform float iTime</code> but then never
uses it, the uniform will be compiled out, and <code>get_uniform_location</code> will
return <code>None</code>. Because the <code>gl.uniform*</code> functions can handle None, the result
is simply that it has no effect.</p>
<p>Another gotcha is that the program must be active (
<code>gl.use_program(Some(&amp;self.program));</code>
) when you set the uniform value.
Otherwise you'll get a warning in console and nothing will happen.</p>
<h1><a class="header" href="#binding-textures" id="binding-textures">Binding Textures</a></h1>
<p>Being able to run a shader is one thing, but a lot of the time we also need
to load in image textures. The way Mozilla suggests in their tutorials is to
use a XMLHttpRequest to fetch the image. However, because we're in a compiled
language we should be able to compile the image into the WASM blob. This isn't
necessarily always a good solution, but for small games it ensures that the
texture will be available at the same time as the WASM is loaded.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D"><code>gl.texImage2D</code></a>
is the function that is used to actually bind the texture. It can take input
in a whole bunch of forms, but most of these forms require uncompressed image data
or an HTML element. Rather than decompress the image in Rust, or decompress it
before including in the binary, we can get the browser to do it for us - we just
need some way to tell the browser to use data from our WASM blob as an image.</p>
<p>Turns out there's some hoops to jump through to get a browser to load an image
from binary data:</p>
<ol>
<li>Convert the bytes into a Javascript Uint8Array</li>
<li>Create a &quot;Blob&quot; object from our Uint8Array</li>
<li>Create a URL so that html can &quot;find&quot; the image</li>
<li>Point an HTMLImageElement at the url pointing at the blob.</li>
</ol>
<p>That translates to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Makes an HTMLImageElement display an image from a bunch of raw bytes.
/// This is useful if you have an image stored with `include_bytes!()`.
/// Assumes image is in PNG format
fn load_image_bytes_to_image_element(
    image_bytes: &amp;[u8],
    img_element: &amp;HtmlImageElement,
) -&gt; Result&lt;(), TextureError&gt; {
    let raw_arr = unsafe { Uint8Array::view(image_bytes) };

    let arr = Array::new();
    arr.set(0, raw_arr.dyn_into().unwrap());

    let mut blob_options = web_sys::BlobPropertyBag::new();
    blob_options.type_(&quot;image/png&quot;);

    let blob: Blob = Blob::new_with_u8_array_sequence_and_options(&amp;arr, &amp;blob_options)?;

    let url = Url::create_object_url_with_blob(&amp;blob)?;
    img_element.set_src(&amp;url);

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>But loading the HTMLImageELement is asynchronus, so outside all of that we need
to:</p>
<ol>
<li>Create a blank texture on the GPU</li>
<li>Start loading the image element</li>
<li>Substitute in the image when it's done.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_texture(gl: &amp;GL, image_bytes: &amp;[u8]) -&gt; Result&lt;WebGlTexture, TextureError&gt; {
    let texture = gl
        .create_texture()
        .ok_or(TextureError::AllocateTextureError)?;

    gl.bind_texture(GL::TEXTURE_2D, Some(&amp;texture));

    // Give our texture a default
    gl.tex_image_2d_with_i32_and_i32_and_i32_and_format_and_type_and_opt_u8_array(
        GL::TEXTURE_2D,
        0,                         // Level
        GL::RGBA as i32,           // Format
        1,                         // width
        1,                         // height
        0,                         // border
        GL::RGBA,                  // source format
        GL::UNSIGNED_BYTE,         // type
        Some(&amp;[255, 0, 255, 255]), // pixels
    )?;

    let img_element = HtmlImageElement::new()?;

    let gl_clone = gl.clone();
    let img_element_clone = img_element.clone();
    let texture_clone = texture.clone();

    let onload = Closure::wrap(Box::new(move || {
        set_up_image(&amp;gl_clone, &amp;img_element_clone, &amp;texture_clone);
    }) as Box&lt;dyn Fn()&gt;);

    img_element.set_onload(Some(onload.as_ref().unchecked_ref()));

    load_image_bytes_to_image_element(image_bytes, &amp;img_element)?;

    onload.forget();

    Ok(texture)
}
<span class="boring">}
</span></code></pre></pre>
<p>You may notice I broke out #3 (substitude in the image when it's done) to a new
function called &quot;set up image&quot;. This is because WebGL needs to know even more
about the image!!!! It needs to know how the shader should sample it, if MipMaps
should be generated.....</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Load an image from an HtmlImageElement to the GPU into the specified
/// texture object. Makes some assumptions about the type of image filtering...
pub fn set_up_image(gl: &amp;GL, img_element: &amp;HtmlImageElement, texture: &amp;WebGlTexture) {
    gl.bind_texture(GL::TEXTURE_2D, Some(&amp;texture));

    gl.pixel_storei(GL::UNPACK_FLIP_Y_WEBGL, 1);

    gl.tex_parameteri(GL::TEXTURE_2D, GL::TEXTURE_MIN_FILTER, GL::NEAREST as i32);
    gl.tex_parameteri(GL::TEXTURE_2D, GL::TEXTURE_MAG_FILTER, GL::NEAREST as i32);

    gl.tex_image_2d_with_u32_and_u32_and_html_image_element(
        GL::TEXTURE_2D,
        0,
        GL::RGBA as i32,
        GL::RGBA,
        GL::UNSIGNED_BYTE,
        &amp;img_element,
    )
    .expect(&quot;Loading Image Failed&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>It's worth mentioning that although we use
<code>load_image_bytes_to_image_elements</code> here, it is trivial to remove that and
instead use the <code>set_src</code> of the <code>image_element</code> to load a URL instead. This
would be useful if you have lots of textures and need to stream them in
dynamically, but for the sorts of games I plan to make it isn't really needed.</p>
<p>Oookay, we should be ready to go now, right? Well....
Lets create a shader that uses a some textures:</p>
<pre><code class="language-glsl">#version 300 es
// Color screen based on on-screen-position

precision mediump float;
in vec4 screen_pos;
out vec4 FragColor;

uniform sampler2D image_texture_1;
uniform sampler2D image_texture_2;

void main() {
    vec2 uv = screen_pos.xy * 0.5 + 0.5;

    if (uv.x &lt; 0.49) {
        FragColor = texture(image_texture_1, uv);
    } else if (uv.x &gt; 0.51) {
        FragColor = texture(image_texture_2, uv);
    } else {
        FragColor = vec4(uv.xy, 0.0, 1.0);
    }
}

</code></pre>
<p>The <code>vec2 uv = screen_pos.xy * 0.5 - 0.5</code> is because the <code>screen_pos</code> variable goes
from -1 to 1, but texture coordinates in the <code>texture</code> function go from 0 to 1.
I'm using two textures just so I can check the binding is happening correctly
(if there is any texture in any texture unit, an unbound sampler seems to use it?!)</p>
<p>Now we need to tell our shader program to use our texture</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Binds a texture to a uniform and a specific texture unit. NOTE: This function
/// has several important things:
///  1) The shader program for the uniform must be active
///  2) The texture_unit parameter is a WebGl2RenderingContext::TEXTURE* constant
pub fn bind_2d_texture_to_uniform(
    gl: &amp;GL,
    uniform: &amp;Option&lt;WebGlUniformLocation&gt;,
    texture: &amp;WebGlTexture,
    texture_unit: TextureUnit,
) {
    // Tell WebGL which texture unit we are configuring
    gl.active_texture(texture_unit.as_gl_const());
    // Tell WebGL what texture to load into the texture unit
    gl.bind_texture(GL::TEXTURE_2D, Some(&amp;texture));
    // Tell WebGL which uniform refers to this texture unit
    gl.uniform1i(uniform.as_ref(), texture_unit.as_int());
}
<span class="boring">}
</span></code></pre></pre>
<p>What's that TextureUnit thing? It's just a handy enum mapping
<code>GL::TextureUnit1</code> to the integer <code>1</code> and making it type safe....</p>
<p>And in our render function we can finally pass in a texture to the shader:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render(&amp;mut self, gl: &amp;WebGl2RenderingContext) {
    gl.use_program(Some(&amp;self.program));

    gl.uniform1f(self.uniform_time.as_ref(), self.time);
    gl.uniform2f(
        self.uniform_resolution.as_ref(),
        self.resolution.0 as f32,
        self.resolution.1 as f32,
    );

    bind_2d_texture_to_uniform(
        &amp;gl,
        &amp;self.uniform_image_texture_1,
        &amp;self.image_texture_1,
        TextureUnit::Unit0,
    );
    bind_2d_texture_to_uniform(
        &amp;gl,
        &amp;self.uniform_image_texture_2,
        &amp;self.image_texture_2,
        TextureUnit::Unit1,
    );

    gl.bind_buffer(
        WebGl2RenderingContext::ARRAY_BUFFER,
        Some(&amp;self.position_buffer),
    );

    gl.vertex_attrib_pointer_with_i32(
        self.attrib_vertex_positions,
        2, // num components
        WebGl2RenderingContext::FLOAT,
        false, // normalize
        0,     // stride
        0,     // offset
    );
    gl.enable_vertex_attrib_array(self.attrib_vertex_positions);

    gl.draw_arrays(
        WebGl2RenderingContext::TRIANGLE_STRIP,
        0, //offset,
        4, // vertex count
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>After all that confuffling, The end result is:</p>
<p><canvas id="binding_textures"></canvas></p>
<h1><a class="header" href="#a-first-game-swoop" id="a-first-game-swoop">A First Game: Swoop</a></h1>
<p>Righto, we can draw things to the screen, we can grab input from the
user, all that remains is to create a game. I'm going to replicate
my shadertoy game &quot;space racer&quot;:</p>
<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WlScWd?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
<p>In shadertoy there are no sprites, so everything there is drawn in a 
single full-screen squad (with some buffering for state). This limits 
what is possible and makes things like the AI and counting laps hard to 
do in a way that will run performantly. By using WebGL only for the 
rendering and using rust/wasm for the collisions/logic, we should be 
able to create a better game.</p>
<h1><a class="header" href="#drawing-the-player-ship" id="drawing-the-player-ship">Drawing The Player Ship</a></h1>
<p>In the <a href="https://www.shadertoy.com/view/WlScWd">shadertoy game</a>, the 
ship is drawn using a signed distance field. That's because you can't 
load custom textures. Here, <a href="swoop_drawing_the_player/../binding_textures/index.html">we just learned how to bind 
textures</a>.
We still want our textures to contain a gradient (as that is what was used
for the neon effect), but now we can draw the ship in a graphics program
like Gimp rather than hand-coding lines as a bunch of coordinates.</p>
<p>Here's our ship texture:</p>
<p><img src="swoop_drawing_the_player/./src/resources/ship.png" alt="Player Ship Texture" /></p>
<p>You may notice it's a little different to the ship we're trying to draw.
That's because I want to be able to turn the engine on and off. I also
think a &quot;collision shield&quot; effect could be quite nice - to let the player
know when they hit things. For this reason, I've put three things on
different channels:</p>
<ol>
<li>Red Channel: the ship</li>
<li>Blue Channel: the ship's engine flame</li>
<li>Green Channel: the ship's collision shield</li>
</ol>
<p>All of these are distance-field-esque, allowing the &quot;blur&quot; to be tuurned
into a nice neon glow.</p>
<p>The fragment shader that does the rendering isn't too complex:</p>
<pre><code class="language-frag">#version 300 es

precision mediump float;
in vec2 uv;
out vec4 FragColor;

uniform sampler2D ship_texture;
uniform float ship_engine;
uniform vec4 ship_color;

vec4 neon(float sdf, vec4 color, float glow_width) {
	float ramp = clamp(1.0 - sdf / glow_width, 0.0, 1.0);
	vec4 outp = vec4(0.0);
	ramp = ramp * ramp;
	outp += pow(color, vec4(4.0)) * ramp;
	ramp = ramp * ramp;
	outp += color * ramp;
	ramp = ramp * ramp;
	outp += vec4(1.0) * ramp;
	return outp;
}

void main() {
	vec4 raw_sprite = texture(ship_texture, uv * 0.5 - 0.5);
	FragColor = neon(1.0 - raw_sprite.r, ship_color, 1.0);
	
	vec4 engine_color = ship_engine * ship_color;
	FragColor += neon(1.0 - raw_sprite.b, engine_color, 1.0) * ship_engine;
}

</code></pre>
<p>You should be able to spot how the shader separates the engine flare 
from the ship, and how it generates the neon gradient of colors.</p>
<hr />
<p>The main challenge here is drawing the player in the right place at
the right size. The vertex shader needs to consider the camera's 
transformation, the aspect ratio of the canvas, and the
transformation of the player's sprite.</p>
<p>To achieve peak runtime efficiency, we should compute/combine these 
matrices on the CPU, and then load a single transformation matrix to 
the GPU (which then processes it for each vertex). 
However, if we wanted to do that we'd need to have matrix maths in 
Rust. Sure, there are crates for that but it would increase the binary 
size and require more data massaging. So instead we will do all the 
matrix maths inside the shader. Note that we can only do this because 
we don't have any object hierarchies. If you had an object hierarchy 
you would need to do math on the CPU to find the final location of the 
objects.</p>
<p>So what math needs to occur inside the shader? We need to end up with
a matrix that takes positions in sprite-local space and converts them
into canvas-clip space.</p>
<p>I find figuring this out much easier with a diagram:</p>
<p><img src="swoop_drawing_the_player/./sprite_transform.svg" alt="Diagram of transforms" /></p>
<p>Using the <a href="https://www.sebastiansylvan.com/post/matrix_naming_convention/">One true naming 
scheme</a> 
for matrices makes this simpler. If we the matrix indicating the 
&quot;sprite transform&quot; matrix <code>world_to_camera</code> (because it represents the 
transformation from world space into sprite space), then we can invert 
it to get <code>camera_to_world</code>.</p>
<p>So we end up with the matrix chain:</p>
<pre><code class="language-glsl">#version 300 es

precision mediump float;
in vec4 aVertexPosition;

uniform mat3 world_to_camera;
uniform mat3 world_to_sprite;
uniform mat3 camera_to_clipspace; // Includes canvas resolution/aspect ratio

out vec2 uv;

void main() {
	mat3 camera_to_world = inverse(world_to_camera);
	mat3 clipspace_to_camera = inverse(camera_to_clipspace);
	mat3 camera_to_sprite = camera_to_world * world_to_sprite;
	mat3 sprite_to_clipspace = clipspace_to_camera * camera_to_sprite;
	
	vec2 pos = (sprite_to_clipspace * vec3(aVertexPosition.xy, 1.0)).xy;
	
	uv = aVertexPosition.xy;
	gl_Position = vec4(pos, 0.0, 1.0);
}
</code></pre>
<hr />
<p>Now, obviously there is a little bit more to getting it to render than just
the shaders. For example,
the object representing the sprite is needs to contain all the new
uniforms:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ShipSprite {
    position_buffer: WebGlBuffer,
    program: WebGlProgram,
    attrib_vertex_positions: u32,
    
    uniform_ship_engine: Option&lt;WebGlUniformLocation&gt;,
    uniform_ship_texture: Option&lt;WebGlUniformLocation&gt;,
    uniform_ship_color: Option&lt;WebGlUniformLocation&gt;,
    
    uniform_world_to_camera: Option&lt;WebGlUniformLocation&gt;,
    uniform_world_to_sprite: Option&lt;WebGlUniformLocation&gt;,
    uniform_camera_to_clipspace: Option&lt;WebGlUniformLocation&gt;,

    pub ship_texture: WebGlTexture,
    pub ship_color: (f32, f32, f32, f32),
    pub ship_engine: f32,
    
    pub world_to_camera: [f32; 9],
    pub world_to_sprite: [f32; 9],
    pub camera_to_clipspace: [f32; 9],
}
<span class="boring">}
</span></code></pre></pre>
<p>And the uniforms have to be set at render-time:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gl.uniform_matrix3fv_with_f32_array(
	self.uniform_world_to_sprite.as_ref(),
	true,
	&amp;self.world_to_sprite
);

// etc.
<span class="boring">}
</span></code></pre></pre>
<p>The various transformation matrices also have to be generated somehow. 
As mentioned before, I didn't want to pull in a full crate like <code>glam</code> 
or <code>nalgebra</code>, so instead I wrote a small module <code>transform.rs</code> 
containing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A non-generic transform in 2D. Only supports rotations translations
/// and a uniform scaling.
pub struct Transform2d {
    pub x: f32,
    pub y: f32,
    pub rot: f32,
    pub scale: f32,
}

impl Transform2d {
    pub fn new(x: f32, y: f32, rot: f32, scale: f32) -&gt; Self {
        Self { x, y, rot, scale }
    }
    pub fn to_mat3_array(&amp;self) -&gt; [f32; 9] {
        let c = f32::cos(self.rot) * self.scale;
        let s = f32::sin(self.rot) * self.scale;

        [c, -s, self.x, s, c, self.y, 0.0, 0.0, 1.0]
    }
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>Finally we have to set everything an invoke render. The nice thing
about working functionally here is that we can invoke render multiple
times after setting different parameters. As such we can render two
ships with one &quot;ship sprite&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn animation_frame(&amp;mut self) {
        let now = window().unwrap().performance().unwrap().now();
        let time = (now / 1000.0) as f32;

        self.check_resize();
        self.gl.clear(
            WebGl2RenderingContext::COLOR_BUFFER_BIT | WebGl2RenderingContext::DEPTH_BUFFER_BIT,
        );

        let mut ship_sprite_transform = Transform2d::new(0.0, 0.0, f32::sin(time), 0.1);

        let camera_transform =
            Transform2d::new(0.0, 0.0, 0.0, 1.0 / self.canvas_resolution.0 as f32);

        self.ship_sprite.world_to_camera = camera_transform.to_mat3_array();
        self.ship_sprite.camera_to_clipspace = [
            self.canvas_resolution.0 as f32,
            0.0,
            0.0,
            0.0,
            self.canvas_resolution.1 as f32,
            0.0,
            0.0,
            0.0,
            1.0,
        ];

		// Render the first ship
        self.ship_sprite.world_to_sprite = ship_sprite_transform.to_mat3_array();
        self.ship_sprite.ship_color = (0.0, 0.5, 1.0, 1.0);
        self.ship_sprite.ship_engine = 0.0;
        self.ship_sprite.render(&amp;self.gl);

		// Render another ship
        ship_sprite_transform.x = f32::sin(time) * 0.5;
        ship_sprite_transform.y = f32::cos(time) * 0.5;
        ship_sprite_transform.rot = - std::f32::consts::PI / 2.0 - time;
        self.ship_sprite.world_to_sprite = ship_sprite_transform.to_mat3_array();
        self.ship_sprite.ship_color = (1.0, 0.5, 0.0, 1.0);
        self.ship_sprite.ship_engine = 1.0;
        self.ship_sprite.render(&amp;self.gl);
    }
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>Proof that it all works:</p>
<p><canvas id="swoop_drawing_the_player"></canvas></p>
<h1><a class="header" href="#drawing-the-map" id="drawing-the-map">Drawing The Map</a></h1>
<p>The map is the background for the everything, so we have two options:</p>
<ol>
<li>Use a plane the size of the map and use the same transform stack as 
for the player ship.</li>
<li>Use a plane the size of the screen and shift the UV coordinates to
match the transform stack.</li>
</ol>
<p>If we were doing an infinite map (ie some sort of exploration game) we 
would have to go with #2, but because we are doing a racing game where
the map is well bounded, solution #1 works just fine and saves a bunch
of effort.</p>
<p>So let's just copy our player sprite code and make it draw a bigger plane
with a different shader. We'll shunt the functions that handle uploading
the shader into a module <code>shader.rs</code>, but we because this is a small
game I won't bother trying to generalize the sprite code. Pretty much
the only code in the <code>ship_sprites.rs</code> and <code>map_sprite.rs</code> is to do
with handling uniforms - which is likely to be pretty shader specific.</p>
<pre><code>use wasm_bindgen::{JsCast, JsValue};
use web_sys::{WebGl2RenderingContext, WebGlBuffer, WebGlProgram, WebGlShader};

/// An error to represent problems with a shader.
#[derive(Debug)]
pub enum ShaderError {
    /// Call to gl.create_shader returned null
    ShaderAllocError,

    /// Call to create_program returned null
    ShaderProgramAllocError,

    ShaderCompileError {
        shader_type: u32,
        compiler_output: String,
    },
    /// Failed to receive error information about why the shader failed to compile
    /// Generally this is indicative of trying to get the error when one hasn't occured
    ShaderGetInfoError,

    /// I think this means that the Vertex and Fragment shaders incompatible
    ShaderLinkError(),

    /// Failed to create buffer to upload data into
    BufferCreationFailed,

    /// Generic javascript error
    JsError(JsValue),
}

impl From&lt;JsValue&gt; for ShaderError {
    fn from(err: JsValue) -&gt; ShaderError {
        ShaderError::JsError(err)
    }
}

pub fn upload_array_f32(
    gl: &amp;WebGl2RenderingContext,
    vertices: Vec&lt;f32&gt;,
) -&gt; Result&lt;WebGlBuffer, ShaderError&gt; {
    let position_buffer = gl
        .create_buffer()
        .ok_or(ShaderError::BufferCreationFailed)?;

    gl.bind_buffer(WebGl2RenderingContext::ARRAY_BUFFER, Some(&amp;position_buffer));

    let memory_buffer = wasm_bindgen::memory()
        .dyn_into::&lt;js_sys::WebAssembly::Memory&gt;()?
        .buffer();

    let vertices_location = vertices.as_ptr() as u32 / 4;

    let vert_array = js_sys::Float32Array::new(&amp;memory_buffer)
        .subarray(vertices_location, vertices_location + vertices.len() as u32);

    gl.buffer_data_with_array_buffer_view(
        WebGl2RenderingContext::ARRAY_BUFFER,
        &amp;vert_array,
        WebGl2RenderingContext::STATIC_DRAW,
    );

    Ok(position_buffer)
}

pub fn load_shader(
    gl: &amp;WebGl2RenderingContext,
    shader_type: u32,
    shader_text: &amp;str,
) -&gt; Result&lt;WebGlShader, ShaderError&gt; {
    let shader = gl
        .create_shader(shader_type)
        .ok_or(ShaderError::ShaderAllocError)?;
    gl.shader_source(&amp;shader, shader_text);
    gl.compile_shader(&amp;shader);
    if !gl
        .get_shader_parameter(&amp;shader, WebGl2RenderingContext::COMPILE_STATUS)
        .is_truthy()
    {
        let compiler_output = &amp;gl
            .get_shader_info_log(&amp;shader)
            .ok_or(ShaderError::ShaderGetInfoError)?;
        gl.delete_shader(Some(&amp;shader));
        return Err(ShaderError::ShaderCompileError {
            shader_type,
            compiler_output: compiler_output.to_string(),
        });
    }
    Ok(shader)
}

pub fn init_shader_program(
    gl: &amp;WebGl2RenderingContext,
    vert_source: &amp;str,
    frag_source: &amp;str,
) -&gt; Result&lt;WebGlProgram, ShaderError&gt; {
    let vert_shader = load_shader(gl, WebGl2RenderingContext::VERTEX_SHADER, vert_source)?;
    let frag_shader = load_shader(gl, WebGl2RenderingContext::FRAGMENT_SHADER, frag_source)?;

    let shader_program = gl
        .create_program()
        .ok_or(ShaderError::ShaderProgramAllocError)?;
    gl.attach_shader(&amp;shader_program, &amp;vert_shader);
    gl.attach_shader(&amp;shader_program, &amp;frag_shader);

    gl.link_program(&amp;shader_program);

    if !(gl.get_program_parameter(&amp;shader_program, WebGl2RenderingContext::LINK_STATUS)).is_truthy()
    {
        gl.delete_program(Some(&amp;shader_program));
        gl.delete_shader(Some(&amp;vert_shader));
        gl.delete_shader(Some(&amp;frag_shader));
        return Err(ShaderError::ShaderLinkError());
    }

    Ok(shader_program)
}
</code></pre>
<p>So anyway, here's drawing the coordinates for the map:</p>
<p><canvas id="swoop_drawing_the_map-0" options="coords"></canvas></p>
<hr />
<p>You may think we would use a texture for the map, just as we did for
the player ship, however the map has slightly different requirements.
As well as being used to show the player where to go, we need to be
able to query the map and find out if a certain area is on the track
or not. While sampling an image is possible, it will be easier to
define the map with a mathematical function. This function can then
be evaluated on the CPU or GPU and will give the same results.</p>
<p>So what function should we use to draw the map? If the map function
returns an approximate distance to the racetrack, then we can use 
finite difference (or possibly an analytic solution) to resolve 
collision normals. So we want a function of the form:</p>
<pre><code class="language-glsl">float map_distance_field = map_function(vec2 position)
</code></pre>
<p>The racetrack should loop back on itself, so it's basic form should
be a circle. We can then distort the circle to make the course more
interesting to race around using a fourier series.</p>
<p>So how do we get the signed distance field for a circle? Well, the
distance from a single point is a good start:</p>
<pre><code class="language-glsl">float course = length(position - vec2(0.0, 0.0));
</code></pre>
<p>We're going to define our distance field as negative values being a drivable
area and positive values being walls. (aka distance to the track).
So lets expand our circle by the track radius:</p>
<pre><code class="language-glsl">float track_sdf = course - track_radius;
</code></pre>
<p>To make things clearer while debugging, let's threshold it so we can
see where the track edges are:</p>
<pre><code class="language-glsl">FragColor = vec4(vec3(track_sdf &gt; 0.0), 1.0);
</code></pre>
<p>This gives us:</p>
<p><canvas id="swoop_drawing_the_map-1" options="circle_1"></canvas></p>
<p>You can see there's a black circle in the middle of the screen. This
would mean that the player can fly anywhere in that circle. We want the
player in a track, not an arena.</p>
<p>To turn it into a ring, we can use the abs function to make it 
symmetric around the current edge, and then offset it to reintroduce 
some negative (track) area:</p>
<pre><code class="language-glsl">track_sdf = abs(track_sdf) - track_width;
</code></pre>
<p><canvas id="swoop_drawing_the_map-2" options="circle_2"></canvas></p>
<p>(Note that the blue ship is invisible because the ships use additive
blending)</p>
<p>Don't understand what is happening here? You're probably not alone.
Signed distance fields (SDF's) are a bit counter-intuitive at first.
I can't think of a good way to explain it, but it should become
evident how it works fairly quickly if you open up shadertoy and have 
a play yourself.</p>
<p>Flying around a circular track isn't very interesting, so we can use 
a fourier series to distort it based on the angle from the center:</p>
<pre><code>#version 300 es

precision mediump float;
in vec2 uv;
out vec4 FragColor;

const float track_base_radius = 0.5;
const float track_width = 0.1;

vec4 sin_consts_1 = vec4(0.2, 0.0, 0.0, 0.0);
vec4 sin_consts_2 = vec4(0.0, 0.0, 0.0, 0.0);
vec4 cos_consts_1 = vec4(0.0, -0.2, 0.0, 0.1);
vec4 cos_consts_2 = vec4(0.0, 0.0, 0.05, 0.0);


float map_function(vec2 position) {
    float course = length(position - vec2(0.0, 0.0));
    
    float angle = atan(position.x, position.y);
    vec4 angles_1 = vec4(angle, angle*2.0, angle*3.0, angle*4.0);
    vec4 angles_2 = vec4(angle*5.0, angle*6.0, angle*7.0, angle*8.0);
    
    float track_radius = track_base_radius;

    track_radius += dot(sin(angles_1), sin_consts_1);
    track_radius += dot(sin(angles_2), sin_consts_2);
    track_radius += dot(cos(angles_1), cos_consts_1);
    track_radius += dot(cos(angles_2), cos_consts_2);

    float track_sdf = course - track_radius;
    track_sdf = abs(track_sdf) - track_width;
    return track_sdf;
}

void main() {
    float track = map_function(uv);
    FragColor = vec4(vec3(track &gt; 0.0), 1.0);
}

</code></pre>
<p>And the resulting track:</p>
<p><canvas id="swoop_drawing_the_map-3" options="fourier_1"></canvas></p>
<p>It shouldn't be hard to port the map function into rust when it comes
time to write the collision detection.</p>
<p>Now to make it look pretty by adding a grid in the background and
drawing some lines around the edge:</p>
<p><canvas id="swoop_drawing_the_map-4" options="visualized"></canvas></p>
<p>Looks like a pretty small map? That's OK, we can tweak it using the
<code>track_width</code> and <code>track_base_radius</code> parameters later.</p>
<p>The final map rendering shader is:</p>
<pre><code>#version 300 es

precision mediump float;
in vec2 uv;
out vec4 FragColor;

const float track_base_radius = 0.5;
const float track_width = 0.1;

const float track_background_grid_spacing = 5.0;
const float track_background_line_fade = 0.04;
const float track_background_line_width = 1.0;
const float track_edge_line_width = 0.5;


vec4 sin_consts_1 = vec4(0.2, 0.0, 0.0, 0.0);
vec4 sin_consts_2 = vec4(0.0, 0.0, 0.0, 0.0);
vec4 cos_consts_1 = vec4(0.0, -0.2, 0.0, 0.1);
vec4 cos_consts_2 = vec4(0.0, 0.0, 0.05, 0.0);


float map_function(vec2 position) {
    float course = length(position - vec2(0.0, 0.0));
    
    float angle = atan(position.x, position.y);
    vec4 angles_1 = vec4(angle, angle*2.0, angle*3.0, angle*4.0);
    vec4 angles_2 = vec4(angle*5.0, angle*6.0, angle*7.0, angle*8.0);
    
    float track_radius = track_base_radius;

    track_radius += dot(sin(angles_1), sin_consts_1);
    track_radius += dot(sin(angles_2), sin_consts_2);
    track_radius += dot(cos(angles_1), cos_consts_1);
    track_radius += dot(cos(angles_2), cos_consts_2);

    float track_sdf = course - track_radius;
    track_sdf = abs(track_sdf) - track_width;
    return track_sdf;
}



vec4 neon(float sdf, vec4 color, float glow_width) {
	float ramp = clamp(1.0 - sdf / glow_width, 0.0, 1.0);
	vec4 outp = vec4(0.0);
	ramp = ramp * ramp;
	outp += pow(color, vec4(4.0)) * ramp;
	ramp = ramp * ramp;
	outp += color * ramp;
	ramp = ramp * ramp;
	outp += vec4(1.0) * ramp;
	return outp;
}


float background_grid(vec2 world_coordinates) {
    vec2 sections = mod(world_coordinates * track_background_grid_spacing, 1.0);
    sections = abs(0.5 - sections);
    vec2 lines = sections + track_background_line_fade;
    lines /= track_background_line_width;
    return min(lines.x, lines.y);
}

float map_edges(float track) {
    return abs(track) / track_edge_line_width;
}


void main() {
    float track = map_function(uv);
    
    float edge_sdf = map_edges(track);
    float background_grid = background_grid(uv);
    
    float map_visualized = edge_sdf;
    if (track &gt; 0.0) {
        map_visualized = min(edge_sdf, background_grid);
    }
    
    
    FragColor = neon(
        map_visualized,
        vec4(0.9, 0.9, 0.9, 1.0), 0.1
    );
}

</code></pre>
<h1><a class="header" href="#ship-motion-physics" id="ship-motion-physics">Ship Motion Physics</a></h1>
<p>Currently the ship sprites are positioned by simple time-varying
functions. We need to switch this to being controlled by some sort of
physics. There are a couple parts to the physics:</p>
<ol>
<li>Motion Dynamics (drag, inertia, application of thrust)</li>
<li>Collision Detection</li>
</ol>
<p>This page will cover the motion dynamics.</p>
<hr />
<p>The first part is to define our in-game ship entity. The ship entity
needs to store the current position, the velocity, and the state of the engine.
To make it easier to render, the ship entity also contains it's color and to
allow the motion physics to be separated from the input/control logic, the
application of force/thrust is also a separate member:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ship {
    pub position: Transform2d,
    pub velocity: Transform2d,
    pub linear_thrust: f32,
    pub turning_thrust: f32,
    pub color: (f32, f32, f32, f32),
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the game we can now create a vector of ships, and render it with
a single ship sprite:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct App {
    ....
    ship_sprite: ShipSprite,
    ship_entities: Vec&lt;Ship&gt;,
    ....
}

&lt;&lt; snip &gt;&gt;

        // Render all the ships
        self.ship_sprite.world_to_camera = world_to_camera;
        self.ship_sprite.camera_to_clipspace = camera_to_clipspace;

        for ship in &amp;self.ship_entities {
            self.ship_sprite.world_to_sprite = ship.position.to_mat3_array();
            self.ship_sprite.ship_color = ship.color;
            self.ship_sprite.ship_engine = ship.linear_thrust;
            self.ship_sprite.render(&amp;self.gl);
        }
<span class="boring">}
</span></code></pre></pre>
<p>So now that we can see our ship entities, what does the motion physics
look like?</p>
<ol>
<li>The engine should provide thrust in the direction the ship is facing</li>
<li>There should be damping/drag to slow the ship down</li>
</ol>
<p>Conceptually:</p>
<pre><code>acceleration -= k_drag * velocity
acceleration += ship_direction * thrust * k_thrust

velocity += acceleration * delta_time
position += velocity * delta_time
</code></pre>
<p>Turns out that's all that's really required:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::transform::Transform2d;

const ENGINE_THRUST: f32 = 10.0;
const TURNING_THRUST: f32 = 40.0;
const LINEAR_DAMPING: f32 = 2.0;
const ANGULAR_DAMPING: f32 = 8.0;

pub struct Ship {
    pub position: Transform2d,
    pub velocity: Transform2d,
    pub linear_thrust: f32,
    pub angular_thrust: f32,
    pub color: (f32, f32, f32, f32),
}

impl Ship {
    pub fn new(color: (f32, f32, f32, f32), start_transform: Transform2d) -&gt; Self {
        Ship {
            position: start_transform,
            velocity: Transform2d::new(0.0, 0.0, 0.0, 0.0),
            linear_thrust: 0.0,
            angular_thrust: 0.0,
            color: color,
        }
    }

    pub fn update(&amp;mut self, dt: f32) {
        let angle: f32 = self.position.rot;

        let c = f32::cos(angle);
        let s = f32::sin(angle);

        let forwards = (-s, c);

        let mut acceleration = (0.0, 0.0, 0.0);
        acceleration.0 += forwards.0 * self.linear_thrust * ENGINE_THRUST;
        acceleration.1 += forwards.1 * self.linear_thrust * ENGINE_THRUST;
        acceleration.2 += self.angular_thrust * TURNING_THRUST;

        acceleration.0 -= self.velocity.x * LINEAR_DAMPING;
        acceleration.1 -= self.velocity.y * LINEAR_DAMPING;
        acceleration.2 -= self.velocity.rot * ANGULAR_DAMPING;

        self.velocity.x += acceleration.0 * dt;
        self.velocity.y += acceleration.1 * dt;
        self.velocity.rot += acceleration.2 * dt;

        // Integration
        self.position.x += self.velocity.x * dt;
        self.position.y += self.velocity.y * dt;
        self.position.rot += self.velocity.rot * dt;

        self.position.rot = wrap_angle(self.position.rot);
    }
}

fn wrap_angle(angle: f32) -&gt; f32 {
    // Ensure a number is between pi and -pi
    // Not sure if this is the optimal way, but it works
    let angle = angle + std::f32::consts::PI; // Work between 0 and 2PI;
    let sig = f32::signum(angle);
    let mag = f32::abs(angle) % (2.0 * std::f32::consts::PI);

    return sig * (mag - std::f32::consts::PI);
}
<span class="boring">}
</span></code></pre></pre>
<p>Connect up some input to one of the ships:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn key_event(&amp;mut self, event: KeyboardEvent) {

        let player_entity = &amp;mut self.ship_entities[0];
        if event.code() == &quot;KeyW&quot; {
            player_entity.linear_thrust = 1.0;
        }
        if event.code() == &quot;KeyS&quot; {
            player_entity.linear_thrust = -1.0;
        }
        if event.code() == &quot;KeyA&quot; {
            player_entity.angular_thrust = 1.0;
        }
        if event.code() == &quot;KeyD&quot; {
            player_entity.angular_thrust = -1.0;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>And we are good to go:</p>
<p><canvas id="swoop_ship_motion_physics"></canvas></p>
<p>You'll notice that once you start turning it keeps turning, that's because
we haven't yet turned the keypress events into something that cleanly
signals if the player is holding the key down or not.
I was also sneaky and defined the camera transform as the X/Y transform
of the player.</p>
<h1><a class="header" href="#keyboard-input" id="keyboard-input">Keyboard Input</a></h1>
<p>In the previous example, the keyboard input acts as though the player
holds down any key he presses. This is because HTML/Javascript doesn't
give us a way to query if a key is currently held down - it only gives
is <code>keydown</code> and <code>keyup</code> events. Back in 
<a href="swoop_ship_keyboard_input/../binding_events/index.html">binding_events</a> we just smashed all
the key events into one. It's time to break those into separate function
calls and to maintain state for the keys we are interested in.</p>
<p>Assing the extra binding is a case of modifying the <code>Core</code> struct to
separate the bindings:</p>
<pre><code>        {
            // keyboard events
            self.canvas.set_tab_index(1); // Canvas elements ignore key events unless they have a tab index
            let anim_app1 = self.app.clone();
            let anim_app2 = self.app.clone();

            let keydown_callback = Closure::wrap(Box::new(move |event: KeyboardEvent| {
                let e: Event = event.clone().dyn_into().unwrap();
                e.stop_propagation();
                e.prevent_default();

                anim_app1.borrow_mut().keydown_event(event);
            }) as Box&lt;dyn FnMut(_)&gt;);
            
            let keyup_callback = Closure::wrap(Box::new(move |event: KeyboardEvent| {
                let e: Event = event.clone().dyn_into().unwrap();
                e.stop_propagation();
                e.prevent_default();

                anim_app2.borrow_mut().keyup_event(event);
            }) as Box&lt;dyn FnMut(_)&gt;);

            self.canvas
                .add_event_listener_with_callback(&quot;keydown&quot;, keydown_callback.as_ref().unchecked_ref())
                .unwrap();
                
            self.canvas
                .add_event_listener_with_callback(&quot;keyup&quot;, keyup_callback.as_ref().unchecked_ref())
                .unwrap();

            keydown_callback.forget();
            keyup_callback.forget();
        }
</code></pre>
<p>And creating the extra function in our App struct:</p>
<pre><code>    pub fn keydown_event(&amp;mut self, event: KeyboardEvent) {
        // Do something
    }
    
    pub fn keyup_event(&amp;mut self, event: KeyboardEvent) {
        // Do something else
    }
</code></pre>
<p>Now we need to mantain the state. Let's create an enum to represent
the state of the keys and how it transitions between states.</p>
<pre><code>impl KeyState {
    fn update(&amp;self) -&gt; KeyState {
        match self {
            KeyState::JustPressed =&gt; KeyState::Down,
            KeyState::Down =&gt; KeyState::Down,
            KeyState::JustReleased =&gt; KeyState::Up,
            KeyState::Up =&gt; KeyState::Up,
        }
    }
    
    fn active(&amp;self) -&gt; bool {
        match self {
            KeyState::JustPressed =&gt; true,
            KeyState::Down =&gt; true,
            KeyState::JustReleased =&gt; false,
            KeyState::Up =&gt; false,
        }
    }
}
</code></pre>
<p>So the idea is that the JS events set the <code>KeyState</code> into
<code>JustPressed</code> or <code>JustReleased</code>, and then on the subsequent frames
it is in the state <code>Down</code> or <code>Up</code>. Code can either query the edge event
by looking at the value of the KeyState directly, or can use the &quot;active&quot;
function to determine if the key is in a &quot;downy&quot; state.</p>
<p>And now create a struct to store the state for each key we're interested in:</p>
<pre><code>struct KeyMap {
    forwards: KeyState,
    backwards: KeyState,
    turn_left: KeyState,
    turn_right: KeyState,
}

impl KeyMap {
    fn new() -&gt; Self {
        Self {
            forwards: KeyState::Up,
            backwards: KeyState::Up,
            turn_left: KeyState::Up,
            turn_right: KeyState::Up,
        }
    }
    
    
    fn update(&amp;mut self) {
        self.forwards = self.forwards.update();
        self.backwards = self.backwards.update();
        self.turn_left = self.turn_left.update();
        self.turn_right = self.turn_right.update();
    }
    
    
    fn set_state_from_str(&amp;mut self, code: &amp;str, new_state: KeyState) {
        match code {
            &quot;KeyW&quot; =&gt; {self.forwards = new_state},
            &quot;KeyS&quot; =&gt; {self.backwards = new_state},
            &quot;KeyA&quot; =&gt; {self.turn_left = new_state},
            &quot;KeyD&quot; =&gt; {self.turn_right = new_state},
            _ =&gt; ()
        };
    }
}
</code></pre>
<p>On the <code>keyup</code> and <code>keydown</code> events the function <code>set_state_from_str</code> will
be called, and on every action frame, <code>update</code> will be called.</p>
<p>One final thing and that is that the <code>keydown</code> event continues to fire when
held down, so the contents of our keydown and keyup functions should be:</p>
<pre><code>    pub fn keydown_event(&amp;mut self, event: KeyboardEvent) {
        if !event.repeat() {
            self.key_map.set_state_from_str(&amp;event.code(), KeyState::JustPressed);
        }
    }
    
    pub fn keyup_event(&amp;mut self, event: KeyboardEvent) {
        self.key_map.set_state_from_str(&amp;event.code(), KeyState::JustReleased);
    }
</code></pre>
<p>Now we can map the state of the <code>key_map</code> to the player in our animation frame
callback:</p>
<pre><code>let player_ship = &amp;mut self.ship_entities[0];
player_ship.linear_thrust = 0.0;
player_ship.angular_thrust = 0.0;
if self.key_map.forwards.active() {
    player_ship.linear_thrust += 1.0
}
if self.key_map.backwards.active() {
    player_ship.linear_thrust -= 1.0
}
if self.key_map.turn_left.active() {
    player_ship.angular_thrust += 1.0
}
if self.key_map.turn_right.active() {
    player_ship.angular_thrust -= 1.0
}
self.key_map.update();
</code></pre>
<p>And the result is:
<canvas id="swoop_ship_keyboard_input"></canvas></p>
<p>Why implement it all this way? Why not convert the key string to an 
enum then use a hashmap to store key state, and make the KeyMap more 
generic? The same reason I didn't factor out generic &quot;sprite drawing 
code&quot; - I'm not trying to make a game engine here, and this is the 
simplest way to get the job done.</p>
<h1><a class="header" href="#collision-physics" id="collision-physics">Collision Physics</a></h1>
<h2><a class="header" href="#collision-with-other-ships" id="collision-with-other-ships">Collision with other ships</a></h2>
<p>Physics is a slightly harder topic in Rust than it would be in other
languages because Rust cares about mutability. So when you go through
an array of objects and generate a set containing pairs of objects, Rust's
borrow checker starts yelling at you.
When you then try an iterate through the pairs and try have mutable
access to them, it yells even more.</p>
<p>Now, when writing the system, the programmer knows that he will never
try to mutate the same object at the same time, but how can we tell Rust
that?</p>
<p>I couldn't think of a good way, so I fell back on run-time reference 
and mutability checks - aka 
<a href="https://doc.rust-lang.org/beta/std/rc/struct.Rc.html"><code>Rc</code></a> and 
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.</p>
<p><code>Rc</code> allows us to have multiple references to the same object, and <code>RefCell</code>
allows us to obtain mutability at runtime - but it will panic if something
else is already borrowing it. That's fine because that now makes it the
programmers job to ensure we don't try to call <code>borrow_mut()</code> twice.</p>
<p>So, we need to end up with a vector of pairs of <code>Rc&lt;RefCell&lt;&amp;mut Ship&gt;&gt;&gt;</code>
Why use <code>&amp;mut Ship</code>? So that our ships stay safely in their existing
vector, and we just fiddle around with references to them. The easiest 
way to get this vector of pairs is to use the <code>itertools::permutations</code> 
which will generate all unique permutations of the vector.</p>
<p>The resulting code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use itertools::Itertools;

let ship_refs = self.ship_entities.iter_mut().map(|x| Rc::new(RefCell::new(x)));
let all_pairs: ship_refs.permutations(2);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can use <code>filter_map</code> to convert the &quot;probable&quot; collision pairs
into details of each collisions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CollisionEvent&lt;'a&gt; {
    obj1: Rc&lt;RefCell&lt;&amp;'a mut Ship&gt;&gt;,
    obj2: Rc&lt;RefCell&lt;&amp;'a mut Ship&gt;&gt;,
    normal: (f32, f32),
    overlap: f32,
}

&lt;&lt; snip &gt;&gt;

let collisions = all_pairs.filter_map(|ships: Vec&lt;Rc&lt;RefCell&lt;&amp;mut Ship&gt;&gt;&gt;| {
    let ship1 = ships[0].clone();
    let ship2 = ships[1].clone();

    let normal = vect_between(&amp;ship1.borrow().position, &amp;ship2.borrow().position);
    let len = length(normal);
    if len &lt; SHIP_RADIUS {
        Some(CollisionEvent {
            obj1: ship1,
            obj2: ship2,
            normal: normalize(normal),
            overlap: len - SHIP_RADIUS,
        })
    } else {
        None
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>And finally we can move the ships when they're colliding:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>collisions.for_each(|pair| {
    let mut ship1 = pair.obj1.borrow_mut();
    let mut ship2 = pair.obj2.borrow_mut();
    
    ship1.position.x -= pair.normal.0 * pair.overlap * 0.5;
    ship1.position.y -= pair.normal.1 * pair.overlap * 0.5;
    ship2.position.x += pair.normal.0 * pair.overlap * 0.5;
    ship2.position.y += pair.normal.1 * pair.overlap * 0.5;
});
<span class="boring">}
</span></code></pre></pre>
<p>For convenience, some of these functions can be broken out of their
inline representation, but you have to specify lifetimes:</p>
<pre><code>fn check_collision&lt;'a&gt;(ship1: Rc&lt;RefCell&lt;&amp;'a mut Ship&gt;&gt;, ship2: Rc&lt;RefCell&lt;&amp;'a mut Ship&gt;&gt;) -&gt; Option&lt;CollisionEvent&lt;'a&gt;&gt;
</code></pre>
<h2><a class="header" href="#collision-with-the-map" id="collision-with-the-map">Collision with the map</a></h2>
<p>When we rendered the map, we used a mathematical function to represent
the map. The advantage of this is that it means we can evaluate the map
on the CPU to determine collisions with the map.</p>
<p>In GLSL this function is:</p>
<pre><code class="language-glsl">vec4 sin_consts_1 = vec4(0.2, 0.0, 0.0, 0.0);
vec4 sin_consts_2 = vec4(0.0, 0.0, 0.0, 0.0);
vec4 cos_consts_1 = vec4(0.0, -0.2, 0.0, 0.1);
vec4 cos_consts_2 = vec4(0.0, 0.0, 0.05, 0.0);


float map_function(vec2 position) {
    float course = length(position - vec2(0.0, 0.0));
    
    float angle = atan(position.x, position.y);
    vec4 angles_1 = vec4(angle, angle*2.0, angle*3.0, angle*4.0);
    vec4 angles_2 = vec4(angle*5.0, angle*6.0, angle*7.0, angle*8.0);
    
    float track_radius = track_base_radius;

    track_radius += dot(sin(angles_1), sin_consts_1);
    track_radius += dot(sin(angles_2), sin_consts_2);
    track_radius += dot(cos(angles_1), cos_consts_1);
    track_radius += dot(cos(angles_2), cos_consts_2);

    float track_sdf = course - track_radius;
    track_sdf = abs(track_sdf) - track_width;
    return track_sdf;
}
</code></pre>
<p>To make it easier to match (and pass values between), I converted this
to:</p>
<pre><code class="language-glsl">const float sin_consts[8] = float[8](0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
const float cos_consts[8] = float[8](0.0, -0.2, 0.0, 0.1, 0.0, 0.0, 0.05, 0.0);


float map_function(vec2 position) {
    float course = length(position - vec2(0.0, 0.0));
    float angle = atan(position.x, position.y);
    float track_radius = track_base_radius;
    
    for (int i=0; i&lt;8; i++) {
        float omega = float(i+1);
        track_radius += cos(angle * omega) * cos_consts[i];
        track_radius += sin(angle * omega) * sin_consts[i];
    }

    float track_sdf = course - track_radius;
    track_sdf = abs(track_sdf) - track_width;
    return track_sdf;
}
</code></pre>
<p>It's a bit less efficient (doesn't take advantage of the GPU being able
to do operations on multiple vector elements at the same time), but GPU
performance isn't likely to be an issue in this game, and it means that 
the rust code looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn distance_field(&amp;self, position: Vec2) -&gt; f32 {
        let course = length(position);
        let angle = position.0.atan2(position.1);
        
        let mut track_radius = self.track_base_radius;
        for i in 0..8 {
            let omega = (i + 1) as f32;
            track_radius += f32::sin(angle * omega) * self.sin_consts[i];
            track_radius += f32::cos(angle * omega) * self.cos_consts[i];
        }

        let mut track_sdf = course - track_radius;
        track_sdf = f32::abs(track_sdf) - self.track_width;
        return track_sdf;
    }
<span class="boring">}
</span></code></pre></pre>
<p>Easy to visually compare for correctness</p>
<p>Detecting if the ship is on/off the map is only half the problem. The
other part is getting the collision normal. One option would be to do
an analytical solution of the fourier series (which wouldn't be too
hard because it's a fourier series), or we can apply finite-difference.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Uses finite difference to approximate the normal. This isn't quite
    // the actual normal because the distance field isn't quite the distance
    // field.
    pub fn calc_normal(&amp;self, position: Vec2) -&gt; Vec2 {
        const DELTA: f32 = 0.01;
        let here = self.distance_field(position);
        let above = self.distance_field((position.0, position.1 + DELTA));
        let right = self.distance_field((position.0 + DELTA, position.1));
        
        let dx = right - here;
        let dy = above - here;
        
        return normalize((dx, dy));
    }
<span class="boring">}
</span></code></pre></pre>
<p>Yeah, I picked finite difference.</p>
<p>From here it's the very similar as for the ship collisions: move the
ship so that it's no longer colliding. I'll also add in a term to slow
the ship motion when colliding with a wall - just to encourage players
not to wall slide.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Collisions with map
    for ship in all_ships.iter_mut() {
        let map_sdf = map.distance_field((ship.position.x, ship.position.y));
        if map_sdf &gt; -SHIP_RADIUS {
            let normal = map.calc_normal((ship.position.x, ship.position.y));
            let overlap = map_sdf + SHIP_RADIUS;
            
            // Place ship back on the map
            ship.position.x -= normal.0 * overlap;
            ship.position.y -= normal.1 * overlap;
            
            // Slow the ship down
            ship.velocity.x -= ship.velocity.x * dt * GROUND_FRICTION;
            ship.velocity.y -= ship.velocity.y * dt * GROUND_FRICTION;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>And there we have it, simple physics completed:</p>
<p><canvas id="swoop_ship_collision_physics"></canvas></p>
<p>You'll notice you can get some jitter when pushing other ships into 
walls and corners. This is because we aren't doing any of the clever 
stuff normal physics engines do to allow object stacking. We'll see if 
that's a problem when we scale the map up.</p>
<h1><a class="header" href="#ship-spawn-points" id="ship-spawn-points">Ship Spawn Points</a></h1>
<p>Currently the ships end up inside the map wherever the physics engine
shunts them. For any sort of game they should be placed somewhere - probably
behind a start/finish line of some sort.</p>
<p>However, before we can place the ships sanely, let's make the map
a sensible size. The function for the map is currently controlled both
in the map shader and in the rust implementation of the map. 
Let's quickly convert the various map control parameters into uniforms:</p>
<pre><code class="language-glsl">uniform float track_base_radius;
uniform float track_width;
uniform float sin_consts[8];
uniform float cos_consts[8];
</code></pre>
<p>And pass them in from rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn set_to_map(&amp;mut self, gl: &amp;WebGl2RenderingContext, map: &amp;Map) {
        gl.use_program(Some(&amp;self.program));
        
        gl.uniform1fv_with_f32_array(self.uniform_sin_consts.as_ref(), &amp;map.sin_consts);
        gl.uniform1fv_with_f32_array(self.uniform_cos_consts.as_ref(), &amp;map.cos_consts);
        gl.uniform1f(self.uniform_track_base_radius.as_ref(), map.track_base_radius);
        gl.uniform1f(self.uniform_track_width.as_ref(), map.track_width);
    }
<span class="boring">}
</span></code></pre></pre>
<p>You may notice I have this as a separate function to being part of the
map sprites &quot;render&quot; function, and that it calls <code>gl.use_program</code>. This
is because the state of a shaders uniform don't need to be set every frame</p>
<ul>
<li>only when they change. For the ships, all the uniforms need to change
each time it is rendered because the same sprite is used for multiple
ships, but for the map (of which there is only one), it only needs to be
set when the map is &quot;selected&quot;. As a result, we can put in our <code>app</code> struct
a function like:</li>
</ul>
<pre><code>    fn start_game(&amp;mut self) {
        self.map_sprite.set_to_map(&amp;self.gl, &amp;self.map);
        // TODO: position the ships on the start line
    }
</code></pre>
<p>Now we can modify the parameters to the map struct, and see it reflected
in the map in the shader!</p>
<hr />
<p>Now that the map is sane enough to &quot;support&quot; a race, let's place a
start line. Where is a good place to putting a start line? Well, the most
important part is that the start line must face in the same direction as
the track.</p>
<p>First up though we need to figure out where the start line should be.
Let's place it at angle 0 - the top of the map. This means that the
player will always initially travel right. We can then find the Y
coordinate of the player by refactoring out the &quot;radius&quot; of the fourier
series:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn track_radius(&amp;self, angle: f32) -&gt; f32 {
        let mut track_radius = self.track_base_radius;
        for i in 0..8 {
            let omega = (i + 1) as f32;
            track_radius += f32::sin(angle * omega) * self.sin_consts[i];
            track_radius += f32::cos(angle * omega) * self.cos_consts[i];
        }
        track_radius
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now we can figure out what angle to place the ships/start line at.
Once again, diagrams come in useful:</p>
<p><img src="swoop_ship_spawn_points/track_angle.svg" alt="How track angle was derived" /></p>
<p>The two rules used were the sine and cosine rules. The resulting rust
function is:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Returns the angle pointing along the track at a particular 
    // polar/angular coordinate along the track
    pub fn get_track_direction(&amp;self, angle: f32) -&gt; f32 {
        const DELTA_ANGLE: f32 = 0.01;
        let radius_here = self.track_radius(angle);
        let radius_a_bit_further = self.track_radius(angle + DELTA_ANGLE);
        let delta_radius = radius_here - radius_a_bit_further;
        
    
        // Use cosine rule to find the length of the line joining the
        // two radius' (chord)
        let joining_side_length = cosine_rule(radius_here, radius_a_bit_further, DELTA_ANGLE);
        
        // Use sin rule to find the angle of the chord and radius_here
        let ratio = radius_here / joining_side_length * f32::sin(DELTA_ANGLE);
        let ratio = f32::max(f32::min(ratio, 1.0), -1.0); // Floating point precision
        let extra_angle = f32::asin(ratio); 
        
        if delta_radius.is_sign_negative() {
            - angle - extra_angle
        } else {
            - angle + extra_angle + std::f32::consts::PI
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Note the differences between theory and implementation:</p>
<ol>
<li>Floating point precision means that the sine rule needed to have it's
inputs clamped.</li>
<li>The distance of the chord is an unsigned number, so information
is lost. The sign of the <code>delta_radius</code> is used to regain this information</li>
</ol>
<p>To test this function I animated the starting angle so I could watch a
ship &quot;fly&quot; along the center line of the track and visually compare the
direction it was moving to the direction it was facing.</p>
<hr />
<p>Now we can place our four ships along the start line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        fn start_game(&amp;mut self) {
        self.map_sprite.set_to_map(&amp;self.gl, &amp;self.map);

        {
            // Position the ships on the start line
            const SHIP_SPACING: f32 = 0.12;
            let start_position = self.map.get_start_position();
            let startline_angle = self.map.get_track_direction(start_position.angle);

            let startline_tangent = (f32::cos(startline_angle), f32::sin(startline_angle));
            let startline_normal = (-f32::sin(startline_angle), f32::cos(startline_angle));

            let num_ships = self.ship_entities.len();

            for (id, ship) in self.ship_entities.iter_mut().enumerate() {
                let offset = ((id as f32) - ((num_ships - 1) as f32) * 0.5);

                let offset_vec = (
                    (startline_tangent.0 * offset - startline_normal.0) * SHIP_SPACING,
                    (startline_tangent.1 * offset - startline_normal.1) * SHIP_SPACING,
                );

                let ship_start_position = start_position.to_cartesian();
                ship.position.x = ship_start_position.0 + offset_vec.0;
                ship.position.y = ship_start_position.1 + offset_vec.1;
                ship.position.rot = startline_angle;

                ship.velocity.x = 0.0;
                ship.velocity.y = 0.0;
                ship.velocity.rot = 0.0;
            }
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Note that we use the normal of the startline to offset the ships behind
the startline slightly.</p>
<p>As a final act, we need to display the startline to the player. We
can add a new function to our map fragment shader:</p>
<pre><code class="language-glsl">
uniform vec2 start_line_tangent;
uniform vec2 start_line_position;

&lt;&lt; snip &gt;&gt;

float startline(vec2 world_coordinates) {
    vec2 delta = world_coordinates - start_line_position;
    float projected_dist = dot(delta, start_line_tangent);
    
    vec2 start_line_coords = delta - projected_dist * start_line_tangent;
    float dist_from_line = length(start_line_coords);
    float dist_from_center = projected_dist;
    
    float start_line_ends = - 1.0 + abs(dist_from_center);
    
    float start_line = max(dist_from_line, start_line_ends);
    
    return start_line + track_background_line_fade;
}

&lt;&lt; snip &gt;&gt;

void main() {
    float track = map_function(uv);
    
    float edge_sdf = map_edges(track);
    
    
    float map_visualized = edge_sdf;
    if (track &gt; 0.0) {
        float background_grid = background_grid(uv);
        map_visualized = min(edge_sdf, background_grid);
    } else {
        float startline_sdf = startline(uv);
        map_visualized = min(edge_sdf, startline_sdf);
    }
    
    
    FragColor = neon(
        map_visualized,
        vec4(0.9, 0.9, 0.9, 1.0), 0.1
    );
}
</code></pre>
<p>Note that in the <code>startline</code> function there is the variable 
&quot;start_line_ends&quot; this is used to prevent the startline from continuing 
across to the other side of the map (the max function is like a 
modeling &quot;intersection&quot; operation).</p>
<p>And the result of all this is:</p>
<p><canvas id="swoop_ship_spawn_points"></canvas></p>
<h1><a class="header" href="#map-generation" id="map-generation">Map Generation</a></h1>
<p>The map is defined by a Fourier series. To generate a new fourier
series, we have to come up with a set of constants for it. We can generate
random numbers with use javascripts <code>Math.random()</code>, and can bind it
into our program with:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wasm_bindgen::prelude::wasm_bindgen;

#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
    #[wasm_bindgen(js_namespace = Math)]
    fn random();
}
<span class="boring">}
</span></code></pre></pre>
<p>A naive implementation of a random map is:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Change the sin and cosine constants to change the map course
    pub fn randomize(&amp;mut self) {
        for i in 0 .. 8 {
            self.sin_consts[i] = (random() - 0.5) * 2.0;
            self.cos_consts[i] = (random() - 0.5) * 2.0;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Which creates maps like:
<img src="swoop_map_generation/maps-naive.png" alt="A selection of maps" /></p>
<p>As you can see, the maps here have LOTS of corners. Racing the one on
the bottom left wouldn't be much fun. This occurs because the amplitude
of the high frequencies can be the same as the amplitude of the low
frequencies.</p>
<p>How about applying a scaling factor to the higher frequencies:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn randomize(&amp;mut self) {
        const WAVINESS: f32 = 2.0;
        for i in 0 .. 8 {
            self.sin_consts[i] = (random() - 0.5) * 2.0 / ((i + 1) as f32) * WAVINESS;
            self.cos_consts[i] = (random() - 0.5) * 2.0 / ((i + 1) as f32) * WAVINESS;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><img src="swoop_map_generation/maps-weighted.png" alt="A selection of maps" /></p>
<p>Yeah, much better. There are nice big features, but there is still a lot
of high-frequency &quot;wobbles&quot;. Maybe instead of having a <code>1/i</code> falloff we
can have a <code>1/(i^n)</code> falloff:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Change the sin and cosine constants to change the map course
    pub fn randomize(&amp;mut self) {
        const WAVINESS: f32 = 3.0;
        for i in 0 .. 8 {
            let rand1 = (random() - 0.5) * 2.0;
            let rand2 = (random() - 0.5) * 2.0;
            let amplitude = WAVINESS / f32::powf((i + 1) as f32, 1.3);
            
            self.sin_consts[i] = rand1 * amplitude;
            self.cos_consts[i] = rand2 * amplitude;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>I found a power of 1.3 turned out quite nice, producing maps with 
straight lines, sweeping curves and the occasional corner:
<img src="swoop_map_generation/maps-power.png" alt="A selection of maps" /></p>
<p>This is the sort of thing you can fiddle with all day, so we'll leave it
here and move on.</p>
<p><canvas id="swoop_map_generation"></canvas></p>
<h1><a class="header" href="#camera-positioning" id="camera-positioning">Camera Positioning</a></h1>
<p>As part of the game, the user should try to avoid crashing into
walls. This should be humanly possible to do.
The ship travels at 4 units/s of velocity and from the center of the
screen to the top edge is 0.5 of a unit. This means that it takes
1/8th of a second for the map to change completely. Human response time 
is a bit slower - about 1/4 to 1/5 of a second. A fun racing game should
be on the limits of this as that is where a user is pushing the edge of
what they can do. To achieve this we need to have about one unit of 
distance between the edge of the screen and the players ship. There are 
two options:</p>
<ol>
<li>Zoom out the camera. This could cause loss of visibility  as the players
ship becomes small</li>
<li>Place the ship off-center away from the ships center of motion. This
could be confusing when the player makes a sudden motion.</li>
</ol>
<p>I think a combination of both will work best, using the players 
velocity to move the center position of the camera and to zoom out when 
the player is moving fast.</p>
<p>So let's create a rough outline of a system for camera positioning:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Camera {
    position: Vec2,
    zoom: f32,
    target_position: Vec2,
    target_velocity: Vec2,
}

impl Camera {
    pub fn new() -&gt; Self {
        Self {
            position: (0.0, 0.0),
            zoom: 1.0,
            target_position: (0.0, 0.0),
            target_velocity: (0.0, 0.0),
        }
    }
    
    pub fn reset(&amp;mut self) {
        self.position = (0.0, 0.0);
        self.zoom = 10.0; // Start zoomed out so there is a nice &quot;zoom&quot; animation at the game start
        self.target_position = (0.0, 0.0);
        self.target_velocity = (0.0, 0.0);
    }
    
    
    /// Set information about the entity the camera is tracking
    pub fn set_target_information(&amp;mut self, pos: &amp;Vec2, vel: &amp;Vec2) {
        self.target_position.0 = pos.0;
        self.target_position.1 = pos.1;
        
        self.target_velocity.0 = vel.0;
        self.target_velocity.1 = vel.1;
    }
    
    ///
    pub fn get_camera_matrix(&amp;self, base_resolution: f32) -&gt; [f32; 9] {
        Transform2d::new(
            self.position.0,
            self.position.1,
            0.0,
            1.0 / base_resolution * self.zoom,
        ).to_mat3_array()
    }
    
    /// Update the position of the camera, moving it towards the target
    /// position.
    pub fn update(&amp;mut self, dt: f32) {
        // Do something fancy in here to position the camera
        self.position.0 = self.target_position.0;
        self.position.1 = self.target_position.1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>What do we put in the update function?</p>
<p>Well, the ideal position is slightly ahead of the player, so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let ideal_position = (
            self.target_position.0 + self.target_velocity.0 * PREDICT_FACTOR,
            self.target_position.1 + self.target_velocity.1 * PREDICT_FACTOR,
        );
<span class="boring">}
</span></code></pre></pre>
<p>And the ideal zoom level is to zoom out the faster the player moves:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let velocity = length(self.target_velocity);
let ideal_zoom = 1.0 + velocity * ZOOM_FACTOR;
<span class="boring">}
</span></code></pre></pre>
<p>To avoid the camera position moving wildly 
when the player changes the ships direction, the camera should move
smoothly towards the ideal position, so let's use a proportional 
controller:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zoom_err = self.zoom - ideal_zoom;
let pos_err = (
    self.position.0 - ideal_position.0,
    self.position.1 - ideal_position.1,
);

self.zoom -= zoom_err * dt / SMOOTHING;

self.position.0 -= pos_err.0 * dt / SMOOTHING;
self.position.1 -= pos_err.1 * dt / SMOOTHING;
<span class="boring">}
</span></code></pre></pre>
<p>Now it's a case of fiddling constants to make it play nicely. You can
do some math to calculate constants to achieve exactly 1 unit of space
ahead of the player, but the end goal is for it to &quot;feel nice&quot; rather
than be precise. In the end, I found some nice constants were:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PREDICT_FACTOR: f32 = 0.6;
const ZOOM_FACTOR: f32 = 0.125;
const SMOOTHING: f32 = 0.4;
<span class="boring">}
</span></code></pre></pre>
<p>The result is:</p>
<p><canvas id="swoop_camera_positioning"></canvas></p>
<p>Now compare it to the previous page. The game is exactly the same, but
you can probably fly around without crashing now!</p>
<h1><a class="header" href="#enemy-racers" id="enemy-racers">Enemy Racers</a></h1>
<p>FLying by yourself around a map is pretty boring, it's time to make the
other players fly!</p>
<p>Lets just wire it in quickly with a function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::ship::Ship;

pub fn calc_ai_control(ship: &amp;mut Ship, skill: f32) {
    ship.linear_thrust = 1.0;
}
<span class="boring">}
</span></code></pre></pre>
<p>And putting it in the core gameloop:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for ship in self.ship_entities[1..].iter_mut() {
    calc_ai_control(ship, 1.0, &amp;self.map);
}
<span class="boring">}
</span></code></pre></pre>
<p>Yes, this does mean there's no state in an AI player - but lets face it,
when you're driving around a map, you don't really consider what you just
did.
Another limitation is that we don't know where the other ships are. Due
to the simplicity of this game, I don't think this will be a problem.</p>
<p>We have a function on our map that we wrote when finding the start positions,
it's called <code>get_track_direction</code> and returns the direction the track is
facing for a given polar coordinate around the track. Similarly, using
the function <code>get_track_radius</code> which also takes in a polar angle, we
can figure out where the full polar coordinates of where the ship would
be if it were on the centerline of the track.</p>
<p>About here I noticed a bug that's been present for quite a while.
I thought the glsl function for atan was <code>atan(x, y)</code> and the rust atan 
function was <code>x.atan(y)</code>. But actually it's <code>atan(y, x)</code> and 
<code>y.atan(x)</code>. Because I've used it consistently wrong, pretty much the 
only effect is that my track polar coordinates are out by 90 degrees. 
Whoops.</p>
<p>I haven't gone through and fixed the previous pages because 
functionally there's no difference, but here's the diff:</p>
<pre><code class="language-diff">diff src/swoop_camera_positioning/src/map.rs src/swoop_enemy_racers/src/map.rs
34c34
&lt;         let angle = position.0.atan2(position.1);
---
&gt;         let angle = position.1.atan2(position.0);
59c59
&lt;         const ANGLE: f32 = 0.0;
---
&gt;         const ANGLE: f32 = std::f32::consts::PI / 2.0;
72c72
&lt;         let delta_radius = radius_here - radius_a_bit_further;
---
&gt;         let delta_radius = radius_a_bit_further - radius_here;
84c84
&lt;             -angle - extra_angle
---
&gt;             angle - extra_angle - std::f32::consts::PI / 2.0
86c86
&lt;             -angle + extra_angle + std::f32::consts::PI
---
&gt;             angle + extra_angle + std::f32::consts::PI / 2.0


diff src/swoop_camera_positioning/src/resources/map.frag src/swoop_enemy_racers/src/resources/map.frag
24c24
&lt;     float angle = atan(position.x, position.y);
---
&gt;     float angle = atan(position.y, position.x);

</code></pre>
<p>Right, that out of the way, we can animate our AI's flying around the 
map by writing directly to their position/rotations:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let polar_position = PolarCoordinate::from_cartesian((ship.position.x, ship.position.y));

    let track_angle_here = map.get_track_direction(polar_position.angle);
    let track_radius_here = map.track_radius(polar_position.angle);

    let track_polar_here = PolarCoordinate {
        angle: polar_position.angle,
        radius: track_radius_here
    };
    let track_centerline_here = track_polar_here.to_cartesian();

    ship.position.x = track_centerline_here.0;
    ship.position.y = track_centerline_here.1;
    ship.position.rot = track_angle_here;
    ship.linear_thrust = 0.1;
<span class="boring">}
</span></code></pre></pre>
<p>However, directly writing the position to the centerline of the track
is a bit of a cheat. We should control the AI with the same controls the
player has: the <code>linear_thrust</code> and <code>angular_thrust</code> variables.</p>
<p>So we have to find a way to convert &quot;ideal&quot; position into a set of 
control inputs. We can divide this problem into two &quot;rules&quot; for the AI:</p>
<ol>
<li>Face in the direction of the track</li>
<li>Try to stay in the center of the track</li>
</ol>
<p>We can compute the difference from facing along the track, and apply
it as a steering input:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let angular_error = wrap_angle(track_angle_here - ship.position.rot);
    ship.angular_thrust = f32::max(f32::min(angular_error, 1.0), -1.0);
<span class="boring">}
</span></code></pre></pre>
<p>This fulfills rule 1, but the AI tends to wallslide. So lets compute 
a radius error and apply that:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let polar_position = PolarCoordinate::from_cartesian((ship.position.x, ship.position.y));

    let track_angle_here = map.get_track_direction(polar_position.angle);
    let track_radius_here = map.track_radius(polar_position.angle);
    
    let mut steering = 0.0;
    let mut thrust = 0.0;
    
    let radius_error = track_radius_here - polar_position.radius;
    let radius_steering_input = f32::max(f32::min(radius_error, PI / 2.0), -PI / 2.0);
    
    let mut target_angle = 0.0;
    target_angle += track_angle_here; // Face direction of track
    target_angle += radius_steering_input;  // Fly towards track center
    
    let angular_error = wrap_angle(target_angle - ship.position.rot);
    steering += angular_error;
   
    thrust += 1.0;

    ship.angular_thrust = f32::max(f32::min(steering, 1.0), -1.0);
    ship.linear_thrust = f32::max(f32::min(thrust, 1.0), -1.0);
<span class="boring">}
</span></code></pre></pre>
<p>Note that the addition of the radius_error is done by offsetting the 
angle we want the ship to fly in rather than direclty influencing the 
steering input. (It's worth noting that the angular error is a kind-of 
feed-forward for the radius error)</p>
<p>The ships now fly around, but still hit the walls lots. This is
because the ships can't see ahead of them. They are flying looking at
how far they are from the walls NOW rather than looking ahead and giving
the ship time to turn. We can fix this by instead of using the ship's current
position to drive the control system, we can use a simple prediction of
the ships position to drive it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let future_position = (
        ship.position.x + ship.velocity.x * LOOKAHEAD_TIME,
        ship.position.y + ship.velocity.y * LOOKAHEAD_TIME,
    );
    
    let polar_position = PolarCoordinate::from_cartesian(future_position);

    let track_angle_here = map.get_track_direction(polar_position.angle);
    let track_radius_here = map.track_radius(polar_position.angle);
    
    let mut steering = 0.0;
    let mut thrust = 0.0;
    
    let radius_error = track_radius_here - polar_position.radius;
    let radius_steering_input = f32::max(f32::min(radius_error, PI / 2.0), -PI / 2.0);
    
    let mut target_angle = 0.0;
    target_angle += track_angle_here; // Face direction of track
    target_angle += radius_steering_input;  // Fly towards track center
    
    let angular_error = wrap_angle(target_angle - ship.position.rot);
    steering += angular_error;
   
    thrust += 1.0;

    ship.angular_thrust = f32::max(f32::min(steering, 1.0), -1.0);
    ship.linear_thrust = f32::max(f32::min(thrust, 1.0), -1.0);
<span class="boring">}
</span></code></pre></pre>
<p>With a lookahead time of 0.5 seconds, the ship navigates the map on a
pretty nice racing line - turning in close on corners etc. However, 
now the ship can only see where it is 0.5 seconds ahead, and doesn't
know where it is now, so when the course is really twisty/turny, it can
still hit the wall.
So let's compute the steering input for both now and for the future:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn calc_ai_control(ship: &amp;mut Ship, _skill: f32, map: &amp;Map) {
    let mut steering = 0.0;
    let mut thrust = 0.0;
    
    steering += calc_steering_input(&amp;ship, &amp;map, 1.0) * 0.15;
    steering += calc_steering_input(&amp;ship, &amp;map, 0.5) * 0.45;
    steering += calc_steering_input(&amp;ship, &amp;map, 0.2) * 0.4;
   
    thrust += 1.0;

    ship.angular_thrust = f32::max(f32::min(steering, 1.0), -1.0);
    ship.linear_thrust = f32::max(f32::min(thrust, 1.0), -1.0);
}


fn calc_steering_input(ship: &amp;Ship, map: &amp;Map, lookahead_time: f32) -&gt; f32 {
    let polar_position = PolarCoordinate::from_cartesian(
        predict_position(ship, lookahead_time)
    );

    let track_angle_here = map.get_track_direction(polar_position.angle);
    let track_radius_here = map.track_radius(polar_position.angle);
    
    let mut steering = 0.0;
    
    let radius_error = track_radius_here - polar_position.radius;
    let radius_steering_input = f32::max(f32::min(radius_error, PI / 2.0), -PI / 2.0);
    
    let mut target_angle = 0.0;
    target_angle += track_angle_here; // Face direction of track
    target_angle += radius_steering_input;  // Fly towards track center
    
    let angular_error = wrap_angle(target_angle - ship.position.rot);
    steering += angular_error;
   
    steering
}

fn predict_position(ship: &amp;Ship, time: f32) -&gt; Vec2 {
    (
        ship.position.x + ship.velocity.x * time,
        ship.position.y + ship.velocity.y * time,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>We now have an AI that can fly inhumanly well. It nails every corner,
and as a result it's no fun to race against (and all the AI's are the 
same). Time to add some imperfections. Let's use the skill parameter to
vary the ships and reduce their lookahead.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num_ships = self.ship_entities.len() - 2;
for (id, ship) in self.ship_entities[1..].iter_mut().enumerate() {
    let skill = id as f32 / num_ships as f32;
    calc_ai_control(ship, skill, &amp;self.map);
}

&lt;&lt; snip &gt;&gt;

pub fn calc_ai_control(ship: &amp;mut Ship, skill: f32, map: &amp;Map) {
    let mut steering = 0.0;
    let mut thrust = 0.0;
    
    let lookahead_mul = skill;
    
    steering += calc_steering_input(&amp;ship, &amp;map, 1.0 * lookahead_mul) * 0.15;
    steering += calc_steering_input(&amp;ship, &amp;map, 0.5 * lookahead_mul) * 0.45;
    steering += calc_steering_input(&amp;ship, &amp;map, 0.2 * lookahead_mul) * 0.4;
   
    thrust += 1.0;

    ship.angular_thrust = f32::max(f32::min(steering, 1.0), -1.0);
    ship.linear_thrust = f32::max(f32::min(thrust, 1.0), -1.0);
}
<span class="boring">}
</span></code></pre></pre>
<p>And there we have it:</p>
<p><canvas id="swoop_enemy_racers"></canvas></p>
<p>I can always beat yellow (no lookahead), often beat yellow (0.5s max 
lookahead) and am not ever close to purple (1s lookahead). I suppose 
this makes sense because the players camera only gives about 0.3-0.5 
seconds of lookahead, so while the AI flies using the same ship 
limitations as a human, it can see more of the map...</p>
<h1><a class="header" href="#engine-trails" id="engine-trails">Engine Trails</a></h1>
<p>Wouldn't it be nice to know how far behind the guy ahead of you is?
That's why the shadertoy implementation has trails behind the ships.</p>
<p>This won't be done as a sprite, but it needs a whole strip of vertices
that will follow the path of the ship. We'll create a strip with fixed
positions and then use a uniform containing some description of the path
and a vertex shader to position the trail.</p>
<h2><a class="header" href="#generating-a-strip-of-triangles" id="generating-a-strip-of-triangles">Generating a strip of triangles</a></h2>
<p>For the sprites we've been using the <code>TRIANGLE_STRIP</code> rendering method,
so this is relatively easy: a triangle is defined by a single vertex 
position and it joins onto the two previous vertex positions.</p>
<p>For each square &quot;segment&quot; we need to add two triangles AKA two new 
vertices. Here we create a the vertex array that fits within a (-1, 1) 
on the X axis and (0, 1) on the Y axis. The Y axis is subdivided into 
<code>SEGMENT_COUNT</code> segments.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut position_buffer = vec![-1.0, 0.0];
position_buffer.extend(&amp;vec![1.0, 0.0]);

for i in 1..SEGMENT_COUNT + 1 {
    position_buffer.extend(&amp;vec![-1.0, i as f32 / SEGMENT_COUNT as f32]);
    position_buffer.extend(&amp;vec![1.0, i as f32 / SEGMENT_COUNT as f32]);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#figuring-out-data-storage" id="figuring-out-data-storage">Figuring out data storage</a></h2>
<p>Now we need to figure out how the program will represent the ships 
path. Fortunately splines are something that are quite well understood.
The basis of nearly all splines (beziers, Catmull Rom etc.) is the 
<a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">Cubic Hermite Spline</a>.
If you want a continuous curve you 
need the endpoint of each curve segment must be located in the same 
space and must have the same tangent (to avoid sharp corners). To do 
this you can derive a function that takes in two positions and two 
tangents and returns a function that interpolates smoothly between 
them. What Mr Hermite figured out was a set of four polynomials that 
would satisfy these constraints.</p>
<p>Aka: <code>curve_segment = F(point1, point2, tangent1, tangent2)</code></p>
<p>All other cubic splines can be converted into this form. Most other 
forms of spline are made to approximate the tangets when all you have 
is a long set of points. However in our case, we can easily get the 
tangents at the points by examining the ships motion!</p>
<p>As we're working in 2D, we can use a single vec4 to contain both points
and tangents: <code>vec4(position_x, position_y, tangent_x, tangent_y)</code>, and
an array of these will nicely define the spline.</p>
<h2><a class="header" href="#storing-the-data" id="storing-the-data">Storing the data</a></h2>
<p>We now need a datastructure to store all the data. We need to be able
to add data onto the end and remove data from the beginning, so the simple
solution is a Deque (double ended queue). Inside it we can store something
like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PathPoint {
    pub position: Vec2,
    pub tangent: Vec2,
}

&lt;&lt; snip &gt;&gt;

pub struct EngineTrail {
    path: VecDeque&lt;PathPoint&gt;,
    max_length: usize,
    time_since_emit: f32,
    prev_position: Vec2,
}
<span class="boring">}
</span></code></pre></pre>
<p>To convert it into an array that can be loaded to our vertex structure
we can iterate through it and flatten it into an array of <code>f32</code>'s.
We have to do this iteration because the dequeue isn't continuous in
memory, so even if we stored f32's inside the dequeue directly, we'd still
have to do some processing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EngineTrail {
    ...
    /// Converts to a buffer containing position/tangent data and one
    /// containing intensity data
    pub fn path_data_buffer(&amp;self) -&gt; Vec&lt;f32&gt;,) {
        let mut point_buffer = vec![];

        for point in self.path.iter() {
            point_buffer.push(point.position.0);
            point_buffer.push(point.position.1);
            point_buffer.push(point.tangent.0);
            point_buffer.push(point.tangent.1);
        }

        point_buffer
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to fill our dequeue with data. From the ship we can find the
position of the engine trail:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ship {
    ...
    pub fn get_engine_position(&amp;self) -&gt; Vec2 {
        let offset = self.position.transform_vec((0.0, -0.4));
        (self.position.x + offset.0, self.position.y + offset.1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And for each ship we can pass this into our engine trail data storage:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl App {
    // Trails
    for (ship, trail) in self.ship_entities.iter().zip(self.engine_trails.iter_mut()) {
        trail.update(
            dt as f32,
            ship.get_engine_position(),
        );
    }
}

&lt;&lt; snip &gt;&gt;

impl EngineTrail {
    ...
    pub fn update(&amp;mut self, dt: f32, position: Vec2, intensity: f32) {
        self.time_since_emit += dt;

        // Ensure the path is completely full of points. Because they
        // have a tangent of zero, they will render with zero width
        // so not be visible.
        if self.path.len() != self.max_length {
            self.path.clear();
            for _ in 0..self.max_length {
                self.path.push_back(PathPoint {
                    position: position,
                    tangent: (0.0, 0.0),
                });
            }
            assert!(self.path.len() == self.max_length)
        }
        
        // Find the ships actual velocity at this instant of time
        let current_tangent = (
            (self.prev_position.0 - position.0) / dt,
            (self.prev_position.1 - position.1) / dt,
        );
        self.prev_position.0 = position.0;
        self.prev_position.1 = position.1;

        // If it's time to add a new segment, rotate the array, making
        // the current zeroth PathPoint into the first PathPoint, the
        // first PathPoint into the second PathPoint etc.
        if self.time_since_emit &gt; TIME_PER_SEGMENT {
            self.path.rotate_right(1);
            self.time_since_emit = dt; // If this is zero, the tangent = 0
        }
        
        {
            // Update the zeroth PathPoint with information about the
            // ship from this instant.
            let first = self.path.get_mut(0).expect(&quot;path invalid&quot;);
            first.position.0 = position.0;
            first.position.1 = position.1;
            first.tangent.0 = current_tangent.0 * self.time_since_emit;
            first.tangent.1 = current_tangent.1 * self.time_since_emit;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Hopefully it's fairly clear how it works. The zeroth element always 
represents where the ship is <em>now</em> and what direction it is traveling 
in <em>now</em>. Whenever a new point is emitted, the zeroth element becomes the
first element, and the last element is now the zeroth element.</p>
<p>The tangent is computed by difference in position rather than reading
the ships velocity because the physics velocity does not necessarily
represent the ships change in position in some situations - such as 
when the ship collides with something. In this case the physics engine
manipulates the position to resolve the collision without altering the
velocity to match. So by storing the <code>previous_position</code> the tangent
matches the actual change in world coordinates.</p>
<h2><a class="header" href="#moving-the-vertices" id="moving-the-vertices">Moving the vertices</a></h2>
<p>Positioning the vertices is done inside the vertex shader - allowing the
computation to be done in parallel.</p>
<p>Given that our triangle strip ranges from (0, 1), we can compute the position
of the information in the array using:</p>
<pre><code class="language-glsl">float vert_id_raw = uv.y * (float(point_buffer_length) - 1.0);
float segment = floor(vert_id_raw);
int index_here = int(segment);
float segment_percent = mod(vert_id_raw, 1.0);
</code></pre>
<p><code>segment</code> and <code>index_here</code> are the position in the array, and 
<code>segment_percent</code> is how far the current vertex is between the two 
<code>index_here</code> and <code>index_here+1</code>.</p>
<p>So now we can extract our data:</p>
<pre><code class="language-glsl">// Find the data that represents this curve segment
vec4 p1 = point_buffer[index_here];
vec4 p2 = point_buffer[index_here+1];

vec2 h0 = p1.xy; // Position
vec2 h1 = p2.xy;
vec2 t0 = p1.zw; // Tangents
vec2 t1 = p2.zw;

if (index_here == 0) {
    // Prevent interpolation in front of the ship
    // This is caused by the h0 and h1 being in very similar positions
    // and t1 causes the curve to precede.
    t1 = normalize(t1) * length(t0);
}
</code></pre>
<p>What's that <code>if (index_here == 0)</code> all about? Well, when a point is added
to the spline, it's just about at the ships position, and the tangent
is saying that the ship is moving forwards quite fast. As a result, the 
spline stretches ahead of the ship! To prevent this the very first 
segment copies the length of the tangent from the zeroth point (where 
the tangent can be scaled with time since the point was emitted) to the 
first point.</p>
<p>Now we can perform the interpolation to find our spline:</p>
<pre><code class="language-glsl">    // Cubic Hermite Interpolation
    float t = segment_percent;
    float t2 = t * t;
    float t3 = t2 * t;
    float H0 = 2.0 * t3 - 3.0 * t2 + 1.0;
    float H1 = -2.0 * t3 + 3.0 * t2;
    float H2 = t3 - 2.0 * t2 + t;
    float H3 = t3 - t2;

    vec2 centerline = h0 * H0 + h1 * H1 + t0 * H2 + t1 * H3;
</code></pre>
<p>Turns out that having tangent information is also very useful when
we try to give our line thickness:</p>
<pre><code class="language-glsl">vec2 tangent = normalize(mix(t0, t1, segment_percent));
vec2 normal = vec2(tangent.y, - tangent.x) * trail_width;
vec2 thickness = normal * aVertexPosition.x;

vec2 vert_position = centerline + thickness;
vec2 pos = (sprite_to_clipspace * vec3(vert_position, 1.0)).xy;
gl_Position = vec4(pos, 0.0, 1.0);
</code></pre>
<p>And we're good to go!</p>
<p><canvas id="swoop_engine_trails"></canvas></p>
<p>Now, there is a bit more to it than was described in this page. I added 
another array called <code>data_buffer</code> that contains if the engine is on or 
not, and to allow smooth motion (because the trail &quot;snaps&quot; every 0.25s, 
there is an offset based on <code>self.time_since_last_emit</code>, but that's just
wiring. I think most of the important parts are covered.</p>
<p>It's really cool to see the trail that purple leaves, and how he nails
those corners!</p>
<p>There are some limitations to this trail implementation: you can see 
some creasing sometimes on sharp corners/collisions, when you &quot;blip&quot; 
the throttle you can often observe the 0.25s spacing between datapoints,
but overall I'm happy with the result.</p>
<p>As a final note, issues with trail rendering can often look amazing. Can
you figure out what cause this issue?
<img src="swoop_engine_trails/trails.png" alt="Loopy Trails" /></p>
<h1><a class="header" href="#wingtip-trails-and-optimizations" id="wingtip-trails-and-optimizations">Wingtip Trails and Optimizations</a></h1>
<p>I think there should be additional trails emitted when the ship &quot;slips 
sideways&quot;. This lets the user see that it's important to fly as straight
as possible, and it may also look pretty cool.</p>
<p>We already have a trail, so we just need some more. We can compute where
to put them with:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ship {

&lt;&lt; snip &gt;&gt;

    pub fn get_wingtip_positions(&amp;self) -&gt; (Vec2, Vec2) {
        let offset_right = self.position.transform_vec((0.43, -0.2));
        let offset_left = self.position.transform_vec((-0.43, -0.2));
        (
            (
                self.position.x + offset_left.0,
                self.position.y + offset_left.1,
            ),
            (
                self.position.x + offset_right.0,
                self.position.y + offset_right.1,
            ),
        )
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And we can change our vector of trails to a vector containing a tuple
of trails, and update each in turn</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct App {
    trails: Vec&lt;(Trail, Trail, Trail)&gt;,
    ...
}


&lt;&lt; snip &gt;&gt;
// Create a set of trails for each ship
let mut trails = vec![];
for ship in ship_entities.iter() {
    const MAIN_TRAIL_WIDTH: f32 = 0.10;
    const WINGTIP_TRAIL_WIDTH: f32 = 0.02;
    const MAIN_TRAIL_BRIGHTNESS: f32 = 0.3;
    const WINGTIP_TRAIL_BRIGHTNESS: f32 = 1.0;

    trails.push((
        Trail::new(ship.color.clone(), MAIN_TRAIL_WIDTH, MAIN_TRAIL_BRIGHTNESS),
        Trail::new(
            ship.color.clone(),
            WINGTIP_TRAIL_WIDTH,
            WINGTIP_TRAIL_BRIGHTNESS,
        ),
        Trail::new(
            ship.color.clone(),
            WINGTIP_TRAIL_WIDTH,
            WINGTIP_TRAIL_BRIGHTNESS,
        ),
    ));
}


&lt;&lt; snip &gt;&gt;
// Update the trails
{
    // Trails
    for (ship, trail) in self.ship_entities.iter().zip(self.trails.iter_mut()) {
        trail.0.update(
            dt as f32,
            ship.get_engine_position(),
            f32::abs(ship.linear_thrust),
        );

        let wingtip_positions = ship.get_wingtip_positions();

        let raw_slip = ship.calc_slip() / 2.5;
        let base_slip = f32::abs(raw_slip);
        let left_slip = base_slip + raw_slip / 8.0;
        let right_slip = base_slip - raw_slip / 8.0;

        trail.1.update(
            dt as f32,
            wingtip_positions.0,
            f32::max(f32::min(left_slip, 1.0), 0.0),
        );
        trail.2.update(
            dt as f32,
            wingtip_positions.1,
            f32::max(f32::min(right_slip, 1.0), 0.0),
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>raw_slip</code> is how much the ships motion is perpendicular to the
way it is facing, and the left and right wingtip trails have slightly
different intensities based on which way the ship is sliding.
The raw slip is calculated with&quot;</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn calc_slip(&amp;self) -&gt; f32 {
        let global_travel = (self.velocity.x, self.velocity.y);
        let local_travel = self.position.to_local_direction(global_travel);

        local_travel.0
    }
<span class="boring">}
</span></code></pre></pre>
<p>Really, that's pretty much all there is to adding the wingtip trails.</p>
<h2><a class="header" href="#optimization" id="optimization">Optimization</a></h2>
<p>This is quite a simple game: a handful of sprites and a pretty non-existant
physics engine. And yet it runs slowly on firefox on my laptop! Similarly
my cellphone struggles and my tablet doesn't show anything at all. So 
let's see what can be done.</p>
<p>The first aim is to minimize calls from WASM to JS. This can be done particularly
in the rendering, where it will also reduce the number of openGL calls.</p>
<h3><a class="header" href="#setup-functions-for-shaders" id="setup-functions-for-shaders">Setup functions for shaders</a></h3>
<p>Currently for each ship we tell the GPU:</p>
<ol>
<li>Use the ship shader, mix it into the scene with additive blending</li>
<li>Use the ship texture</li>
<li>Use the ship sprite vertex buffer</li>
<li>Configure the camera setup</li>
<li>Configure the ship color, engine etc.</li>
<li>Render the actual ship</li>
</ol>
<p>Steps 1-4 are redundant for every ship other than the first one because
the shader settings and the camera position are the same for each ship.</p>
<p>As a result we can break our ship render function into a &quot;setup&quot; function
and a &quot;render ship&quot; function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn setup(&amp;mut self, gl: &amp;WebGl2RenderingContext) {
        gl.use_program(Some(&amp;self.program));
        gl.blend_func(WebGl2RenderingContext::ONE, WebGl2RenderingContext::ONE);

        gl.uniform_matrix3fv_with_f32_array(
            self.uniform_world_to_camera.as_ref(),
            true,
            &amp;self.world_to_camera,
        );
        gl.uniform_matrix3fv_with_f32_array(
            self.uniform_camera_to_clipspace.as_ref(),
            true,
            &amp;self.camera_to_clipspace,
        );

        bind_2d_texture_to_uniform(
            &amp;gl,
            &amp;self.uniform_ship_texture,
            &amp;self.ship_texture,
            TextureUnit::Unit0,
        );

        gl.bind_buffer(
            WebGl2RenderingContext::ARRAY_BUFFER,
            Some(&amp;self.position_buffer),
        );

        gl.vertex_attrib_pointer_with_i32(
            self.attrib_vertex_positions,
            2, // num components
            WebGl2RenderingContext::FLOAT,
            false, // normalize
            0,     // stride
            0,     // offset
        );
        gl.enable_vertex_attrib_array(self.attrib_vertex_positions);
    }

    pub fn render(&amp;mut self, gl: &amp;WebGl2RenderingContext, ship: &amp;Ship) {
        gl.uniform_matrix3fv_with_f32_array(
            self.uniform_world_to_sprite.as_ref(),
            true,
            &amp;ship.position.to_mat3_array(),
        );

        gl.uniform4f(
            self.uniform_ship_color.as_ref(),
            ship.color.0,
            ship.color.1,
            ship.color.2,
            ship.color.3,
        );
        gl.uniform1f(self.uniform_ship_engine.as_ref(), ship.linear_thrust);

        gl.draw_arrays(
            WebGl2RenderingContext::TRIANGLE_STRIP,
            0, //offset,
            4, // vertex count
        );
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now we can render our ships with:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.ship_sprite.world_to_camera = world_to_camera;
self.ship_sprite.camera_to_clipspace = camera_to_clipspace;
self.ship_sprite.setup(&amp;self.gl);
for ship in &amp;self.ship_entities {
    self.ship_sprite.render(&amp;self.gl, ship);
}
<span class="boring">}
</span></code></pre></pre>
<p>Nice and simple, and we've removed 8 WASM -&gt; JS -&gt; GPU calls for each 
ship. We can do this for the other sprites as well.</p>
<p>So what did this optimization do? Well, without trails there were 66 
webgl calls per frame. With a single trail per ship as implemented on 
the previous page there were 122 webgl calls per frame. With three 
trails per ship this would mean there would be 234 calls if we kept the 
previous implementations. But now there are only 104 calls per frame! Sure,
there are still more vertices and more data flying around, but there is
less overhead.</p>
<p>(The version with 3 trails per ship has 17 draw calls, all the other 
calls are setting the shader program, setting uniforms etc. Another 
point of interest is that there are a total of 2444 vertices rendered)</p>
<h3><a class="header" href="#combining-data-in-trail-shader" id="combining-data-in-trail-shader">Combining data in trail shader</a></h3>
<p>The trail currently uses two buffers: one for point information and one
for data information. It then indexes into both of these for each 
vertex. This requires two WASM -&gt; JS -&gt; GPU calls, and requires the GPU 
to hold both buffers in cache. We can combine these into one buffer and
then use:</p>
<pre><code class="language-glsl">// Find the data that represents this curve segment
int index_here = int(segment) * 2;
vec4 p1 = point_buffer[index_here];
vec4 p2 = point_buffer[index_here+2];
vec4 d1 = point_buffer[index_here+1];
vec4 d2 = point_buffer[index_here+3];
</code></pre>
<p>To extract point positional information and data information. Again 
this reduces the JS/WASM calls, but it should also improves the GPU's 
caching as all the data for a particular point is near itself in 
memory.</p>
<h3><a class="header" href="#increase-map-shader-efficiency" id="increase-map-shader-efficiency">Increase map shader efficiency</a></h3>
<p>Back in the original map shader we used two vec4's to hold the sin/cos 
constants. This was changed to a float array when we implemented physics
as it allowed easier comparison for differences between the GPU and CPU 
implementation.
Now that we know it's working we can put it back.</p>
<pre><code class="language-glsl">// From this:
uniform float sin_consts[8];
uniform float cos_consts[8];

float track_radius = track_base_radius;

for (int i=0; i&lt;8; i++) {
    float omega = float(i+1);
    track_radius += cos(angle * omega) * cos_consts[i];
    track_radius += sin(angle * omega) * sin_consts[i];
}

// To this:
uniform vec4 sin_consts[2];
uniform vec4 cos_consts[2];

vec4 angles_1 = vec4(angle, angle*2.0, angle*3.0, angle*4.0);
vec4 angles_2 = vec4(angle*5.0, angle*6.0, angle*7.0, angle*8.0);

vec4 sin_consts_1 = sin_consts[0];
vec4 sin_consts_2 = sin_consts[1];
vec4 cos_consts_1 = cos_consts[0];
vec4 cos_consts_2 = cos_consts[1];

float track_radius = track_base_radius;
track_radius += dot(sin(angles_1), sin_consts_1);
track_radius += dot(sin(angles_2), sin_consts_2);
track_radius += dot(cos(angles_1), cos_consts_1);
track_radius += dot(cos(angles_2), cos_consts_2);
</code></pre>
<p>The most important difference is that the version with the <code>uniform  float sin_consts[8]</code> requires 8 samples into the array whereas the <code>uniform vec4 sin_consts[2];</code>
only requires two. It may not seem like a big difference as the same amount of
data is extracted, but my understanding of how uniforms work is that a GPU is
optimized for operating on vec4's, so a uniform float is actually just the first
element of a vec4 and the rest are discarded.</p>
<p>The other performance improvement is that we are now doing two 
<code>sin(vec4)</code> instead of eight <code>sin(float)</code>. My understanding of 
GPU architecture suggests that, similar to above, it will compute 
<code>sin(vec4)</code> in the same number of cycles as <code>sin(float)</code>, so two 
<code>sin(vec4)</code>s will run in 1/4 of the time as eight <code>sin(float)</code>s.</p>
<p>Trig is normally pretty heavy computations, as are array samples on a 
GPU, so here we've reduced both of them.</p>
<h3><a class="header" href="#rust-performance-optimizations" id="rust-performance-optimizations">Rust performance optimizations?</a></h3>
<p>If it's slow, is it the rust/WASM that's slow? If we look at the firefox
profile we see:
<img src="swoop_wingtip_trails/firefox_waterfall.png" alt="Waterfall showing maximum animation frame time is 2.8ms" /></p>
<p>So even on one frame where the animation frame callback is strangely long, the
maximum length is 2.72ms. For 60FPS the timing target is 16ms, so that's under
20% of the maximum possible time.</p>
<p>Looking at the flamechart we can see that the time is listed as &quot;graphics&quot;.
I'm not quite sure what this means. 
<img src="swoop_wingtip_trails/firefox_flamechart.png" alt="flamechart showing time as &quot;graphics&quot;" /></p>
<p>At this point I discovered that I'm not able to get anything to maintain 
60FPS in firefox at fullscreen (1920x1080). Firefox has some open bugs 
on this and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1010527"><em>all</em> webgl runs slowly on firefox on 
linux</a>. As a 
result there's nothing I can do to solve this problem (it's to do with 
how firefox transfers the pixels from the canvas to the screen)</p>
<h3><a class="header" href="#how-about-the-cellphone-and-tablet" id="how-about-the-cellphone-and-tablet">How about the cellphone and tablet</a></h3>
<p>Fortunately you can profile remotely on Chrome, so we can find out at 
least some information about what's going wrong on the cellphone. Let's
start with the tablet.</p>
<h4><a class="header" href="#fixing-the-tablet" id="fixing-the-tablet">Fixing the Tablet</a></h4>
<p>The tablet shows a black screen on all of the games in the swoop project,
even the very first &quot;drawing the player ship&quot; one, and yet it can 
render the &quot;binding textures&quot; example just fine. There is very minimal
difference between these two. One of the differences is all the matrix
transformations: <code>world_to_camera</code>, <code>world_to_sprite</code> etc. After
some debugging I found that it forcing the camera and clipspace matrices
to be identity matrices fixed the issue.
Previously these had the value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera_to_clipspace = [
    self.canvas_resolution.0 as f32,
    0.0,
    0.0,
    0.0,
    self.canvas_resolution.1 as f32,
    0.0,
    0.0,
    0.0,
    1.0,
];
<span class="boring">}
</span></code></pre></pre>
<p>Some fiddling with feeding different values into these matrices resulted
in the discovery that at a certain value, they just stopped working.
On a whim, I tried changing <code>precision mediump float</code> to <code>precision  highp float</code>, and it suddenly started working.</p>
<p>Clearly some more investigation into precision was needed. The OpenGL ES
specifications provide the minimum requirements for <code>mediump</code> as
a floating point range of <code>-2^14</code> to <code>2^14</code> (±16384), and a relative 
precision of <code>2^-10</code>. We aren't anywhere near 16k resolution, and I 
wouldn't think we were needing <code>1920.0e-10</code> precision, but maybe the 
inverse operation causes the matrices to become degenerate?</p>
<p>There are two solutions:</p>
<ol>
<li>Use highp precision</li>
<li>Instead of feeding the canvas resolution through the camera/clipspace
matrices, use zoom and aspect ratio. </li>
</ol>
<p>Because #2 was simple to implement I gave it a go, but another problem 
showed up: all the motion now &quot;snapped&quot; between positions as the 
precision of the matrices allowed. So there's only the one
solution: use <code>highp</code>. However I will keep the changes from #2 as they 
mean that the camera object no longer needs to know the canvas 
resolution, which is a bit nicer architecturally.</p>
<p>The changes are</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CAMERA.RS
pub fn get_camera_matrix(&amp;self) -&gt; [f32; 9] {
    Transform2d::new(
        self.position.0,
        self.position.1,
        0.0,
        self.zoom,
    )
    .to_mat3_array()
}

// APP.RS
let world_to_camera = self
    .camera
    .get_camera_matrix();
let camera_to_clipspace = [
    1.0,
    0.0,
    0.0,
    0.0,
    (self.canvas_resolution.1 as f32 / self.canvas_resolution.0 as f32),
    0.0,
    0.0,
    0.0,
    1.0,
];
<span class="boring">}
</span></code></pre></pre>
<p>and the change of many <code>mediump</code> to <code>highp</code>.</p>
<p>One other thing I noticed (it was hard to miss) was that the map looked
like:</p>
<p><img src="swoop_wingtip_trails/./blocky_map.jpg" alt="Map all pixelated" /></p>
<p>Urgh! Looks like another precision problem. Sure enough, changing the
map's fragment shader from mediump to highp fixed the problem.</p>
<p>My guess is that my desktop always runs with 16 or 32 bit floats (the 
requirements specify the minimum precision), and my tablet runs with 
lower-precision floats, which is why this problem was only observed on
the tablet. I don't know what floating point
representation my tablet uses - the track radius is an average of 8 
units across and the tablet seems to have a resolution of only 0.1 
units at that point - so it looks like it's probably using 9-bit 
floats - far short of the 14 bits it should be using with the <code>mediump</code> 
specifier (or my understanding of float precision is wrong).</p>
<p>Performance on the tablet is fine. The chrome profiler reports most of 
the time as &quot;idle&quot;, but while profiling it still drops a few frames. 
When not connected via android debugger, it visually appears to run at 
60FPS all the time, making me suspect it's related to chrome capturing
screenshots while profiling. Disabling screenshotting in the profiler
results in a nice clean 60FPS all the time.</p>
<h4><a class="header" href="#on-the-phone" id="on-the-phone">On the phone</a></h4>
<p>Opening up the chrome profiler on the phone revealed that the WASM took
3.25ms to run, and the GPU spent 7ms rendering. Together this is 10.25ms
still under the 16ms timinig budget. However, for some reason the phone
was only firing animationFrame callbacks every 20-25ms resulting in a 
stuttering performance. </p>
<p>I tried other webGL demos and the result was the same. My guess is that
Chrome is trying to save battery by restricting the frame rate - even
though it's plugged in for these tests. Oh well, nothing I can do here.</p>
<h3><a class="header" href="#the-strange-case-of-the-js-heap" id="the-strange-case-of-the-js-heap">The strange case of the JS Heap.</a></h3>
<p>The JS heap is growing and then getting garbage collected. Arrgh! I'm 
not using much JS at all, so why is this happening?</p>
<p>My guess is that every time I set a uniform with an array, it creates a JS
array from rust, and abandons it over to JS. This is likely because
I'm using <code>uniform4fv_with_f32_array()</code>. Perhaps this could be improved
if I used <code>uniform4fv_with_f32_sequence</code> and passed in/edited the same 
JSValue each time?
For this game with just a handful of sprites the heap grows slowly 
enough I don't consider it a problem, but this is worth investigating 
in the future.</p>
<h3><a class="header" href="#the-end-result" id="the-end-result">The End result</a></h3>
<p><canvas id="swoop_wingtip_trails"></canvas></p>
<p>There shouldn't be much difference except it has engine trails and 
should run a touch better.</p>
<h1><a class="header" href="#start-sequence" id="start-sequence">Start Sequence</a></h1>
<p>Currently the game just starts. There's no time for the player to prepare.
We need a title sequence with a &quot;press enter to start&quot;. To do this
I want to render a logo as well as ... text.</p>
<p>Let's start with the logo, because that's the easiest.</p>
<h2><a class="header" href="#rendering-a-logo" id="rendering-a-logo">Rendering a logo</a></h2>
<p>My idea for a logo is to have the word &quot;swoop&quot; drawn by two of the 
ships and their trails. One ship will write the &quot;S&quot; and the other will 
write &quot;woop&quot;.
For this I need a to generate some trails with the correct points for
the shapes I want. I could do this by hand and trial-and-error, but
it's much easier to author the trail in, say, blender, and then
export the positions/tangents it into a rust file.</p>
<p>The rust file contains a struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Logo {
    pub trails: Vec&lt;Trail&gt;,
    pub ships: Vec&lt;Ship&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>And then a python script goes through and generates an initilizer
containing things like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut out = Self {
            trails: vec![],
            ships: vec![]
        };
        
        
        let mut trail = Trail::new(
            (0.699999988079071, 0.0, 1.0, 1.0),
            1.0,
            1.0,
        );
        trail.path.push_front(PathPoint {
            position: (-2.191507339477539, -0.6047587394714355),
            tangent: (-3.393470287322998, -0.7639043927192688),
            intensity: 1.0,
            width: 0.019999999552965164,
            brightness: 100.0,
        });
        trail.path.push_front(PathPoint {
            position: (-0.9643271565437317, 0.12513494491577148),
            tangent: (0.225080206990242, -0.3531510829925537),
            intensity: 1.0,
            width: 0.019999999552965164,
            brightness: 100.0,
        });
        trail.path.push_front(PathPoint {
            position: (-0.6066954731941223, 0.765639066696167),
            tangent: (-0.9081510305404663, -0.5753495693206787),
            intensity: 1.0,
            width: 0.019999999552965164,
            brightness: 100.0,
        });
        out.trails.push(trail);
        
// And so on
<span class="boring">}
</span></code></pre></pre>
<p>The code that does this is pretty ugly (as is a lot of exporter code), 
and is inside the <code>resources/logo.blend</code> file.</p>
<p>To render our logo, we can  move our existing game logic to a &quot;play_game&quot;
function, and create a new function called &quot;show_logo&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn show_logo(&amp;mut self) {
        self.check_resize();
        self.gl.clear(
            WebGl2RenderingContext::COLOR_BUFFER_BIT | WebGl2RenderingContext::DEPTH_BUFFER_BIT,
        );
        let camera_to_clipspace = [
            1.0,
            0.0,
            0.0,
            0.0,
            (self.canvas_resolution.1 as f32 / self.canvas_resolution.0 as f32),
            0.0,
            0.0,
            0.0,
            1.0,
        ];
        self.trail_sprite.camera_to_clipspace = camera_to_clipspace;
        
        let world_to_camera = Transform2d::new(0.0, -0.7, 0.0, 3.0).to_mat3_array();
        let world_to_trails = Transform2d::new(0.0, 0.0, 0.0, 1.0).to_mat3_array();
        
        self.trail_sprite.world_to_camera = world_to_camera;
        self.trail_sprite.world_to_sprite = world_to_trails;
        
        self.trail_sprite.setup(&amp;self.gl);
        for trail in &amp;self.logo.trails {
            self.trail_sprite.render(&amp;self.gl, &amp;trail);
        }
        
        self.ship_sprite.camera_to_clipspace = camera_to_clipspace;
        self.ship_sprite.world_to_camera = world_to_camera;
        for ship in &amp;self.logo.ships {
            self.ship_sprite.setup(&amp;self.gl);
            self.ship_sprite.render(&amp;self.gl, &amp;ship);
        }
        
    }
<span class="boring">}
</span></code></pre></pre>
<p>We can now swap this in place of the previous <code>animation_frame</code> function
to preview our title screen:</p>
<p><img src="swoop_start_sequence/logo.png" alt="Title Screen" /></p>
<p>The cool thing about doing the logo this way rather than with a sprite is
that if we change how trails are rendered, or what a ship looks like,
the logo will update. Also, it means we don't have to pack a high-res 
sprite containing the logo into the binary.</p>
<p>Now, I think the player should be able to see the map in the background,
so let's extend our <code>show_logo</code> function to include the map sprite:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map_sprite_transform = Transform2d::new(0.0, -1.0, 0.0, 0.1);
// Render the map
self.map_sprite.world_to_camera = world_to_camera;
self.map_sprite.camera_to_clipspace = camera_to_clipspace;
self.map_sprite.world_to_sprite = map_sprite_transform.to_mat3_array();
self.map_sprite.render(&amp;self.gl);
<span class="boring">}
</span></code></pre></pre>
<p>Maybe in the future we can allow the user to cycle through maps? We'll
shelve that for now.</p>
<h2><a class="header" href="#game-start-state-machine" id="game-start-state-machine">Game start state machine</a></h2>
<p>So now we have a function for showing the logo and a function for
playing the game. We should create an enum and some logic to allow
us to switch between them:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GameState {
    Menu,
    Playing,
}

&lt;&lt; snip &gt;&gt;

if self.key_map.start_game.active() {
    self.game_state = GameState::Playing;
    return;
}
<span class="boring">}
</span></code></pre></pre>
<p>I also had to add the start_game key to the keymap as per one of the
previous articles.</p>
<p>Now we need to tell the user to press the Enter key...</p>
<h2><a class="header" href="#rendering-characters" id="rendering-characters">Rendering Characters</a></h2>
<p>Drawing text is a pain - wrapping words, kerning, scaling and a host of
other quirks. Lets make it as simple as possible: a sprite sheet of 
signed distance fields for the letters, a monospace font, and while we're
at it, why not use a single quad to draw a whole block of text rather
than a quad per character.</p>
<p>What do I mean by that? Well, if you have a monospace font, you can,
figure out what character a pixel is part of just by looking at it's
coordinages. Maybe a diagram will help:</p>
<p><img src="swoop_start_sequence/character_decompose.png" alt="How to find a character from the quad" /></p>
<p>This is how text rendering is done in shadertoy.
So, for this we need a spritesheet containing all the characters. With
the help of python and the python image library we can generate this
quite easily. But to enable a smaller texture, we really want a distance
field texture. With a bit more python finagling, We end up with the font
sheet:</p>
<p><img src="swoop_start_sequence/src/resources/font.png" alt="Font Sheet" /></p>
<p>This image is only 128px, and so is ~10kb, but if we treat it like a
signed distance field and threshold it, we can make it really big. Here 
it is 100 times enlarged:</p>
<p><img src="swoop_start_sequence/letter_b.png" alt="A really big letter B" /></p>
<p>Not so bad - and there shouldn't need to be any text that large! And you
do realize that on the character sheet each character is only 16 
pixels tall?</p>
<p>So now we need to get it into the engine. We've done this before with
the ship sprite, so I won't go into depth here. The fun part is the
fragment shader.
First we need to be able to select a part of the image to sample:</p>
<pre><code class="language-glsl">vec4 get_sprite(vec2 uv, vec2 offset, vec2 size) {
        return texture(font_texture, uv * size + offset);
}
</code></pre>
<p>Our sprite sheet has all the characters the same size, so we can
index from the bottom up: <code>A = 10</code>, <code>B = 11</code>, <code>K = 20</code> etc.
So let's convert from these single integer indexes into an offset:</p>
<pre><code class="language-glsl">vec4 get_character(vec2 uv, int character) {
        vec2 offset = vec2(ivec2(
                character % TILES.x,
                character / TILES.x
        )) * CHARACTER_SIZE;
        return get_sprite(uv, offset, CHARACTER_SIZE);
}
</code></pre>
<p>Now we can draw a single large character across our entire quad. How
about dividing it into segments:</p>
<pre><code class="language-glsl">        vec2 coord = uv * 0.5 + 0.5;

        coord.x *= float(text_box_size.x);
        coord.y *= float(text_box_size.y);
        int letter_id = int(coord.x) + (text_box_size.y - int(coord.y) - 1) * text_box_size.x;
        coord.x -= floor(coord.x);
        coord.y -= floor(coord.y);
</code></pre>
<p>The variable <code>letter_id</code> tells us which segment we are in. 
If we were to run <code>get_character(coord, letter_id)</code> we would get the
quad filled with the characters from the font sheet in order. We want
to spell out a sentence, so let's create an array containing the
characters we want:</p>
<pre><code class="language-glsl">vec4 characters[16] = vec4[16](
        vec4(0.0, 0.7, 1.0, 25.0),
        vec4(0.0, 1.0, 0.0, 47.0),
        vec4(0.7, 0.0, 1.0, 36.0),
        vec4(1.0, 0.0, 0.0, 60.0),
        vec4(1.0, 0.0, 0.0, 40.0),
        vec4(1.0, 0.0, 0.0, 53.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0),
        vec4(1.0, 0.0, 0.0, 69.0)
);

ivec2 text_box_size = ivec2(8, 2);
</code></pre>
<p>I've used a vec4 so the first three can represent color. So we can now
use the <code>neon</code> function from the ship/map/everything to make glowing
letters.</p>
<pre><code class="language-glsl">        float char_sdf = get_character(coord, int(char_data.a)).r;
        FragColor = neon(
                1.0 - smoothstep(0.0, 0.5, char_sdf),
                vec4(char_data.rgb, 1.0),
                1.0
        );
</code></pre>
<p>So does it work?</p>
<p><img src="swoop_start_sequence/first_letters.png" alt="The world &quot;Player&quot; spelled out" /></p>
<p>Woohoo, technicolor writing in a single quad!</p>
<p>Now you've probably noticed that I put the ship sprite in the red 
channel of the character sheet. This means that with a small tweak we
can render the player ship as a character in our text. This may be
useful for displaying a leader-board.</p>
<p>The tweak to be able to access it is in <code>get_character</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>float get_character(vec2 uv, int character) {
        vec2 offset = vec2(ivec2(
                character % TILES.x,
                character / TILES.x
        )) * CHARACTER_SIZE;
        
        vec2 size = CHARACTER_SIZE;
        vec4 channel = vec4(0.0, 1.0, 0.0, 0.0);
        
        if (character == -1) {
                size = vec2(1.0);
                offset = vec2(0.0);
                channel = vec4(1.0, 0.0, 0.0, 0.0);
        }
        vec4 color = get_sprite(uv, offset, size);
        return dot(color, channel);
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can render a player ship inline as a character - and
it's high res (128px compared to 16px).</p>
<p><img src="swoop_start_sequence/players.png" alt="A bunch of ships" /></p>
<p>THe only thing left is a bit of vertex shader tweaking to position
and resize the text box.</p>
<pre><code class="language-glsl">/// How many characters wide and high the text box is
uniform ivec2 text_box_dimensions;

/// how tall (in screen space) a single character should be
uniform float character_height;

/// Where the center of the text box should be located (in screen space)
uniform vec2 anchor;

/// Aspect ratio of the screen
uniform float screen_aspect;

&lt;&lt; snip &gt;&gt;

	float character_width = character_height * 5.0 / 9.0;
	vec2 text_box_size = vec2(
		character_width * float(text_box_dimensions.x),
		character_height * float(text_box_dimensions.y)
	);

	uv = aVertexPosition.xy;
	vec2 pos = uv * text_box_size + anchor;
	pos.x *= screen_aspect;
	gl_Position = vec4(pos, 0.0, 1.0);
</code></pre>
<p>Nothing too complex there, just scaling and positioning
based on a bunch of uniforms</p>
<h2><a class="header" href="#a-rust-interface" id="a-rust-interface">A Rust Interface</a></h2>
<p>Currently the text is hardcoded into the shader as a bunch of numbers.
We want to be able to use a nicer API for displaying things.
Perhaps something like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TextBox::new();
TextBox.extend(&quot;some characters&quot;, BLUE);

text_sprite.(TextBox);
<span class="boring">}
</span></code></pre></pre>
<p>So let's create a struct that contains all the important properties
for a text object:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The thing that can be drawn with a text sprite.
pub struct TextBox {
    data: Vec&lt;f32&gt;,

    // The text box wraps character wise and permits width*height characters to be displayed
    box_dimensions: (i32, i32),

    /// Height of a single character As percentage of screen size
    character_height: f32, 
    
    /// Where on the screen to draw the text. Positions the center of the text box with the screen ranging from -1.0 to 1.0 on both axis.
    anchor: (f32, f32)
}
<span class="boring">}
</span></code></pre></pre>
<p>We need to convert from the character &quot;A&quot; to it's numeric representation.
My initial implementation was going to be a match statement, then a hashmap.
After a bit of thinking, I came up with a simple solution:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TextBox {
    const VALID_CHARS: &amp;'static str = &quot;0123456789ABCDFEGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:-&lt;&gt;*[] &quot;;
    
&lt;&lt; snip &gt;&gt;

    /// The Text sprite has characters encoded in a non-standard order.
    /// This does the conversion
    fn encode_char(c: char) -&gt; f32 {
        match Self::VALID_CHARS.find(c) {
            Some(id) =&gt; id as f32,
            None =&gt; -1.0,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Yup, a simple lookup in a vec. It's not <code>O(1)</code>, but with only 70 characters
it shouldn't be a problem. Any unknown characters result in <code>-1</code> which, if you
remember, is the ship sprite.</p>
<p>A simple function to do whole strings at a time:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn append_string(&amp;mut self, string: &amp;str, color: &amp;[f32; 3]){
        for c in string.chars() {
            self.data.extend(color);
            self.data.push(Self::encode_char(c));
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>After that it's just a case of plumbing the data into the vertex shader.</p>
<h2><a class="header" href="#a-bit-of-refactoring" id="a-bit-of-refactoring">A bit of refactoring</a></h2>
<p>The App struct is becoming quite large, holding a reference to all the sprites,
all the entities, and all the rendering code. This is also a problem because we
can't have a function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl App {
    fn game_update(&amp;mut self) {
        self.render(&amp;self.ships)
    }

    fn render(&amp;mut self, &amp;Vec&lt;Ship&gt;){
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you're not a rustacean, you probably are wondering why you can't do this.
Well, the render function is getting passed a mutable reference to self and
a reference to self.ships. The mutable reference to self contains a reference
to ships, so we have a mutable and immutable reference to the same memory.</p>
<p>Because we now have to render both the main menu and the game while it's
playing, a bit of refactoring makes sense. I chose to split out all the
rendering code into a Renderer struct. This contains all the sprites and
contains a render function that (essentially) takes the world state:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Renderer {
    pub gl: WebGl2RenderingContext,
    canvas: HtmlCanvasElement,
    ship_sprite: ShipSprite,
    pub map_sprite: MapSprite,
    trail_sprite: TrailSprite,
    text_sprite: TextSprite,

    canvas_resolution: (u32, u32),
}

impl Renderer {

&lt;&lt;&lt; snip &gt;&gt;&gt;

pub fn render(
        &amp;mut self,
        camera_transform: &amp;Transform2d,
        ships: Vec&lt;&amp;Ship&gt;,
        trails: Vec&lt;&amp;Trail&gt;,
        text_boxes: Vec&lt;&amp;TextBox&gt;,
    ) {
            &lt;&lt; omitted &gt;&gt;
    }


<span class="boring">}
</span></code></pre></pre>
<p>Why is map_sprite and gl public? Yeah, they shouldn't be. In the previous code
the map uniforms were only set when the map was updated - which makes sense
because the map doesn't change very often. I kept this. It is not the best
architecturally, but there is only one map at a time and this will always(?)
be the case. I can tell I'm going to regret this later :)</p>
<p>Why does the render function take a Vector of references rather than a 
reference to a vector of objects? Thats because the things aren't always
stored in linear form. Consider the trails which were <code>Vec&lt;(Trail, Trail, Trail)&gt;</code> (I did change this though...) or that for the UI, storing a single
array of TextBox's may not make much sense. So a vector of references allows
flexibility in how/where the objects themselves are stored.</p>
<h2><a class="header" href="#countdown" id="countdown">Countdown</a></h2>
<p>So, after that whole lot we can push &quot;Enter&quot; and the game starts immediately.
As a final part of the start sequence it would be great to have a &quot;3&quot;, &quot;2&quot;,
&quot;1&quot;, &quot;Go!&quot; countdown.</p>
<p>We could do this as a separate game state in the GameState enum, but I think it
would be better to do it as part of the GamePlaying state.</p>
<p>Speaking of which, let's refactor the game playing state to a new file while 
we're at it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GamePlay {
    pub map: Map,
    pub ship_entities: Vec&lt;Ship&gt;,
    pub trails: Vec&lt;Trail&gt;,
    pub camera: Camera,

    pub game_duration: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>And I moved all the logic (keyboard control, AI, physics) into this struct's
<code>update</code> function. I've also added a <code>game_duration</code> field:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GamePlay{
    pub fn new() -&gt; Self {

        &lt;&lt; snip &gt;&gt;

        Self {
            map,
            ship_entities,
            trails,
            camera,
            game_duration: -3.0
        }
    }

    pub fn update(&amp;mut self, dt: f64, key_map: &amp;KeyMap) {
        self.game_duration += dt;
        if self.game_duration &lt; 0.0 {
            // Do the countdown!

        } else {
            calc_ship_physics(&amp;mut self.ship_entities, &amp;self.map, dt as f32);
        }

        self.steer_ships(key_map);
        self.update_trails(dt);

        self.camera.target_position.0 = self.ship_entities[0].position.x;
        self.camera.target_position.1 = self.ship_entities[0].position.y;
        self.camera.target_velocity.0 = self.ship_entities[0].velocity.x;
        self.camera.target_velocity.1 = self.ship_entities[0].velocity.y;
        self.camera.update(dt as f32);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Oh hey, now the ships don't move for the first three seconds because the
physics isn't updated. </p>
<p>We can now create a text box for the countdown and update it as needed</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    pub fn update(&amp;mut self, dt: f64, key_map: &amp;KeyMap) {
        self.game_duration += dt;
        if self.game_duration &lt; 0.0 {
            // Do the countdown!
            self.countdown_text.clear();
            
            let remaining = -self.game_duration.floor();
            let diff = 1.0 - remaining - self.game_duration;

            self.countdown_text.append_string(
                &amp;format!(&quot; {} &quot;, remaining as u8),
                &amp;[0.0, diff as f32, 0.0]
            );
        } else {
            if self.game_duration &lt; 1.0 {
                self.countdown_text.clear();
                self.countdown_text.append_string(&amp;&quot;Go!&quot;, &amp;[0.0, 1.0 - self.game_duration as f32, 0.0]);
            }
            calc_ship_physics(&amp;mut self.ship_entities, &amp;self.map, dt as f32);
        }
<span class="boring">}
</span></code></pre></pre>
<p>That was a long one but here we have it: A menu and a countdown at the
start of the game. </p>
<p><canvas id="swoop_start_sequence"></canvas></p>
<h1><a class="header" href="#counting-laps" id="counting-laps">Counting Laps</a></h1>
<p>The main purpose of this game is to fly the ship around the map and
be faster than the AI's. The game needs to keep track of the laps so
that it an tell who wins.</p>
<p>So how can we count laps? Well, we can check if the player crosses
the start line. How do we know when this happens? Well, if we have the
transform of the start line we can check which side of the start line
a ship is currently on. Then we can track when it changes side.</p>
<p>So let's create a struct to represent the score:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Score {
    laps: Vec&lt;f64&gt;,
    previous_progress: f32
}
<span class="boring">}
</span></code></pre></pre>
<p>Why is laps a vector of f64's? Surely it should be an integer of some
sort? Well, we may as well store the time in which the lap is completed.
The lap count is easily derived using <code>score.laps.len()</code> and as a bonus
the time difference between players is easily calculable.</p>
<p>And the previous_progress is to store a value telling how far around
the track the player is. Assuming we have a way to tell how far around
they are, we can do:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Checks if the player crosses the start/finish line and updates
    /// the score to match
    pub fn update(&amp;self, map: &amp;Map, ship: &amp;Ship, time: f64) {
        let current_progress = map.calc_progress_relative_to_startline((ship.position.x, ship.position.y));
        
        // Progress has jumped from previously being near 1.0 (nearly completed)
        // to being near 0.0 (just started), so they probably did a lap
        if self.previous_progress &gt; 0.8 &amp;&amp; current_progress &lt; 0.2{
            self.laps.push(time);
        }
        
        // Progress has jumped from previously being near 0.0 (just started)
        // to being close to 1.0 (nearly completed) so the player went back
        // across the line.
        if self.previous_progress &lt; 0.2 &amp;&amp; current_progress &gt; 0.8{
            self.laps.pop();
        }
        
        self.previous_progress = current_progress
    }
<span class="boring">}
</span></code></pre></pre>
<p>This uses a mythical <code>map.calc_progress_relative_to_startline</code> function that takes
a position in global coordinates and returns a single floating point
number. This number should jump jump from 1.0 to 0.0 when the player crosses the
start line, and can be anything else when the player is a long way away.</p>
<p>You may have expected it to be zero at the start line and go positive/negative when
moving each direction, but then you have to deal with a discontinuity and where the
startline is. By placing the discontinuity at the start line it reduces the number
of edge cases.</p>
<p>So how can we <code>calc_progress_relative_to_startline</code>. One way would be to convert
the player position into polar coordinates and use the angle. But this wouldn't
take the &quot;tilt&quot; of the startline into account so would only be accurate for the middle
of the track. But if we transform the ships position into the local coordinate
system of the start line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let start_position = self.get_start_position();
let start_line_direction = self.get_track_direction(start_position.angle);

let start_position_cartesian = start_position.to_cartesian();

let distance_from_startline = (
    position.0 - start_position_cartesian.0,
    position.1 - start_position_cartesian.1
);

let s = f32::sin(-start_line_direction);
let c = f32::cos(-start_line_direction);

let position_local = (
    c*distance_from_startline.0 - s*distance_from_startline.1,
    s*distance_from_startline.0 + c*distance_from_startline.1
);
<span class="boring">}
</span></code></pre></pre>
<p>We can then check to see if the player is near the start line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if f32::abs(position_local.0) &gt; self.track_width {
    // Position is off to the side of the track
    0.5
} else {
    // Offset so that start line is at progress = 1.0
    let progress = position_local.1 + 1.0;

    if progress &gt; 1.5 {
        // Position is a long way in front of the line
        0.5
    } else if progress &lt; 0.5 {
        // Position is a long way behind the line
        0.5
    } else
<span class="boring">}
</span></code></pre></pre>
<p>And force the discontinuity to be at 0.0/1.0 boundary</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Position is near the line. We want the returned
// nunmber to be between 0.0 and 1.0 and the discontinuty
// to be at the start line. Currently `progress` goes
// from 0.5 to 1.5
if progress &gt; 1.0 {
    progress - 1.0
} else {
    progress
}
<span class="boring">}
</span></code></pre></pre>
<p>ANd now we can count laps!</p>
<h1><a class="header" href="#display-a-leader-board" id="display-a-leader-board">Display a leader board</a></h1>
<p>It would be cool for the player to be able to know how far behind the
leader they are (I have great faith in human's piloting ability...).
In my mind the leaderboard should be structured:</p>
<pre><code>LAP 2/3
&lt;SHIP&gt;:  00.00
&lt;SHIP&gt;: +03.13
&lt;SHIP&gt;: +07.32
&lt;SHIP&gt;: +23.50

</code></pre>
<p>The <code>&lt;SHIP&gt;</code> is the ship glyph in the font, and the number is the number of
seconds behind the leader. If the leader is on a different lap, the leaderboard
can display:</p>
<pre><code>LAP 2/3
&lt;SHIP&gt;:  00.00
&lt;SHIP&gt;: +03.13
&lt;SHIP&gt;: +--.--
&lt;SHIP&gt;: +--.--
</code></pre>
<p>We have all the scores in an array, so let's sort a vector of reference to them
in order of lap and then timing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn generate_leaderboard_text(&amp;mut self) {
        self.leaderboard_text.clear();

        let mut ship_and_score_refs: Vec&lt;(&amp;Ship, &amp;Score)&gt; = self.ship_entities.iter().zip(self.scores.iter()).collect();
        ship_and_score_refs.sort_by(|a, b| { a.1.cmp(b.1)});
<span class="boring">}
</span></code></pre></pre>
<p>Hmm, what's this <code>cmp</code> function? Technically it should be an
implementation of the <code>Ord</code> trait, but to implement <code>Ord</code> you also
need to implementation <code>Eq</code> and <code>PartialOrd</code> and <code>PartialEq</code>. So
instead of <code>impl Ord for Score</code> I'm just putting the cmp function
in the <code>imp Score</code> block.
When sorting scores, first we need to sort by the lap counter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        let a_laps = self.laps.len();
        let b_laps = other.laps.len();
        let a_last_lap = self.laps.last();
        let b_last_lap = other.laps.last();

        if a_laps &gt; b_laps {
            Ordering::Less
        } else if a_laps &lt; b_laps {
            Ordering::Greater
        } else {
            ....????
        }
<span class="boring">}
</span></code></pre></pre>
<p>If the laps are the same, we need to sort by the least time:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if let Some(a_last_lap) = a_last_lap {
        if let Some(b_last_lap) = b_last_lap {
            // Both scores show at least one lap, so compare times
            if a_last_lap &gt; b_last_lap {
                // A has the longer time, so is doing worse
                Ordering::Greater
            } else {
                Ordering::Less
            }
        } else {
            // b has not done any laps
            Ordering::Less
        }
    } else {
        if b_last_lap.is_some() {
            // b has done some laps, a has not
            Ordering::Greater
        } else {
            Ordering::Equal
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Some of these conditions should never be hit - if 
<code>a_last_lap.is_some()</code>, then <code>b_last_lap</code> will also be 
<code>is_some()</code> because we check that the number of laps is
the same. I can't think of a way to express this to the
compiler, so it'll just be a bit more verbose than it
needs to be.</p>
<p>Now that we can sort a list of scores we can find the winner and 
format the scoreboard as described above. The resulting function
is:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn generate_leaderboard_text(&amp;mut self) {
        self.leaderboard_text.clear();

        let mut ship_and_score_refs: Vec&lt;(&amp;Ship, &amp;Score)&gt; =
            self.ship_entities.iter().zip(self.scores.iter()).collect();
        ship_and_score_refs.sort_by(|a, b| a.1.cmp(b.1));
        let winner_score = ship_and_score_refs.first().expect(&quot;No Ships&quot;).1;

        self.leaderboard_text.append_string(
            &amp;format!(&quot;Lap {}/{}  &quot;, winner_score.laps.len(), NUM_LAPS_TO_WIN),
            &amp;[0.5, 0.5, 0.5],
        );
        for (ship, score) in ship_and_score_refs {
            let color = [ship.color.0, ship.color.1, ship.color.2];
            if score.laps.len() == winner_score.laps.len() {
                if let Some(winner_time) = winner_score.laps.last() {
                    // Same lap - display time
                    let time = score.laps.last().unwrap() - winner_time;
                    let seconds = time as u32;
                    let millis = (time.fract() * 100.0).floor() as u32;
                    self.leaderboard_text
                        .append_string(&amp;format!(&quot;~ {:02}:{:02}  &quot;, seconds, millis), &amp;color);
                } else {
                    // No-one has any time yet
                    self.leaderboard_text
                        .append_string(&amp;format!(&quot;~ --:--  &quot;,), &amp;color);
                }
            } else {
                // This player is at least a lap behind
                self.leaderboard_text
                    .append_string(&amp;format!(&quot;~ --:--  &quot;,), &amp;color);
            }
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>The <code>unwrap</code> should never be encountered for the same reason as
mentioned above. We only get there when 
<code>winner_score.laps.last().is_some()</code> and when the length of the two laps arrays are equal. If someone knows how to tell the compiler this,
I'd love to know!</p>
<p>Anyway, the only thing to do now is to play it and see how far ahead
purple actually gets.....</p>
<p><canvas id="swoop_counting_laps"></canvas></p>
<h1><a class="header" href="#win-condition" id="win-condition">Win Condition</a></h1>
<p>We can now count laps, but the lap counter goes up indefinitely.
At some point teh game should end and you should see a more
detailed scoreboard - things like best lap time and average lap time.</p>
<p>Let's put a new state in the GameState enum:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GameState {
    Menu,
    Playing,
    ScoreScreen,
}
<span class="boring">}
</span></code></pre></pre>
<p>And a function to the gameplay struct to check if the game is
completed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns True when the game is complete.
    /// The game is considered complete when everyone has
    /// done enough laps
    pub fn game_complete(&amp;self) -&gt; bool {
        for score in self.scores.iter() {
            if score.laps.len() &lt; NUM_LAPS_TO_WIN {
                return false
            }
        }
        return true
    }
<span class="boring">}
</span></code></pre></pre>
<p>And in the App struct's play_game function, we can now initiate
the state change:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn play_game(&amp;mut self, dt: f64) {
        self.gameplay.update(dt, &amp;self.key_map);
        let ship_entity_refs = self.gameplay.ship_entities.iter().collect();
        let trail_entity_refs = self.gameplay.trails.iter().collect();

        self.renderer.render(
            &amp;self.gameplay.camera.get_camera_matrix(),
            ship_entity_refs,
            trail_entity_refs,
            self.gameplay.get_text_entities(),
        );

        // If the game is finished, show the score screen
        if self.gameplay.game_complete() {
            self.game_state = GameState::ScoreScreen;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>And we can write another function that runs in the <code>ScoreScreen</code> state:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn show_scores(&amp;mut self, dt: f64) {
        self.gameplay.update(dt * 0.1, &amp;self.key_map);
        let ship_entity_refs = self.gameplay.ship_entities.iter().collect();
        let trail_entity_refs = self.gameplay.trails.iter().collect();

        self.renderer.render(
            &amp;self.gameplay.camera.get_camera_matrix(),
            ship_entity_refs,
            trail_entity_refs,
            self.score_screen.get_text_entities(),
        );

        // If the game is finished, show the score screen
        if self.key_map.start_game == KeyState::JustReleased {
            self.game_state = GameState::Menu;
            self.reset();
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>You may notice something strange there. I'm still calling <code>self.gameplay.update</code>
and I'm still rendering the ship entities and trails. That's because I think
it would be cool for the game to continue slow-motion in the background.</p>
<p>I have, of course, created a ScoreScreen struct that contains the text
entities. There's not much particularly complex in it except for the
code that populates the score screen text:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ScoreScreen {

    &lt;&lt;&lt; snip &gt;&gt;&gt;

    pub fn populate_scores(&amp;mut self, ships: &amp;Vec&lt;Ship&gt;, scores: &amp;Vec&lt;Score&gt;) {
        self.scores.clear();

        let mut ship_and_score_refs: Vec&lt;(&amp;Ship, &amp;Score)&gt; =
            ships.iter().zip(scores.iter()).collect();
        ship_and_score_refs.sort_by(|a, b| a.1.cmp(b.1));

        self.scores.append_string(&quot;   Avg   Best&quot;, &amp;[0.5, 0.5, 0.5]);

        for (ship, score) in ship_and_score_refs {
            let color = [ship.color.0, ship.color.1, ship.color.2];
            
            let best_lap = score.get_best_lap();
            let average_lap = score.get_average_lap();
            
            self.scores.append_string(&quot;~ &quot;, &amp;color);
            self.scores.append_string(&amp;format_time(average_lap), &amp;color);
            self.scores.append_string(&quot; &quot;, &amp;color);
            self.scores.append_string(&amp;format_time(best_lap), &amp;color);
        }
    }

}

fn format_time(time: Option&lt;f64&gt;) -&gt; String {
    if let Some(sec) = time {
        let seconds = sec as u32;
        let millis = (sec.fract() * 100.0).floor() as u32;
        format!(&quot;{:02}:{:02}&quot;, seconds, millis)
    } else {
        &quot;--:--&quot;.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Not to much complex there, just fetch the average and best lap times for
each player. Oops, better implement those:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Score {

    &lt;&lt;&lt; snip &gt;&gt;&gt;
    /// Returns a vector of the times for each lap
    pub fn get_lap_timings(&amp;self) -&gt; Vec&lt;f64&gt; {
        let mut lap_times = vec![];
        let mut lap_start_time = 0.0;
        for lap_end_time in &amp;self.laps {
            lap_times.push(lap_end_time - lap_start_time);
            lap_start_time = *lap_end_time;
        }
        // First &quot;lap&quot; is the time it takes to get across
        // the start line
        lap_times.drain(0..1);
        lap_times
    }

    /// Returns the average lap time
    pub fn get_average_lap(&amp;self) -&gt; Option&lt;f64&gt; {
        let lap_timings = self.get_lap_timings();

        if lap_timings.len() &gt; 0 {
            let mut total_time = 0.0;
            for lap_time in &amp;lap_timings {
                total_time += lap_time
            }
            Some(total_time / (lap_timings.len() as f64))
        } else {
            None
        }
        
    }

    pub fn get_best_lap(&amp;self) -&gt; Option&lt;f64&gt; {
        let mut lap_timings = self.get_lap_timings();
        
        // Lap timings should never be NAN
        lap_timings.sort_by(|a, b| a.partial_cmp(b).unwrap());
        lap_timings.first().cloned()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Remember how the scores are stored as the times that the player
crosses the line? This means that we need the function <code>get_lap_timings()</code> 
to get the duration for each lap.</p>
<p>And that's about it really for the score screen.</p>
<p><canvas id="swoop_win_condition"></canvas></p>
<h1><a class="header" href="#stl-viewer" id="stl-viewer">STL Viewer</a></h1>
<p>STL files are commonly used in 3D printing, and are easy to generate
in code. One project idea I have in mind is to use Rust to generate
files for 3D printing on the users web browser. It would be nice if
the pipeline was:</p>
<pre><code>User Configuration --&gt; STL --&gt; Preview Rendering
                        |
                        V
                 Download files
</code></pre>
<p>This way you can be sure that what the user (and developer) sees is what
ends up being created.</p>
<p>One part of this project is to develop a renderer that takes in STL 
files and allows the user to rotate the view around them.</p>
<h1><a class="header" href="#stl-viewer-1" id="stl-viewer-1">STL Viewer</a></h1>
<p>So far we've dealt with 2D, but often we want things in 3D. The simplest
3D application I could think of is a STL viewer. So, how do we go from
2D to 3D? Well, we can no longer use a triangle strip to generate a quad,
instead we have to use face indices to determine how the vertices are
joined. We also have to include face normals because faces can now point
in different directions.</p>
<p>The code for this is based this off the <code>Binding Textures</code> page.</p>
<h2><a class="header" href="#loading-the-stl" id="loading-the-stl">Loading the STL</a></h2>
<p>There are two formats for STL's: ascii and binary. For this we'll assume
correctly formatted binary STL's. Because we're bundling them into the binary
rather than letting the user select the STL, this will be robust enough. 
If this were to be a &quot;generic&quot; STL viewer we'd need to have more advanced
error handling.</p>
<p>So, what is an STL file? The first 80 bytes are a header and are ignored.
The next four bytes represent the number of faces. Then, for each face
there is a face normal and three vertex positions (all as three f32's), and
a u16 extra-data.
We can extract all this information into it's raw parts using:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extact_buffers_from_stl(stl: &amp;[u8]) -&gt; (Vec&lt;u16&gt;, Vec&lt;f32&gt;, Vec&lt;f32&gt;) {
    let mut faces = std::vec::Vec::new();
    let mut vertices = std::vec::Vec::new();
    let mut normals = std::vec::Vec::new();

    let num_faces = u32::from_le_bytes(stl[80..84].try_into().unwrap());

    for face in 0..(num_faces) {
        const STRIDE: u32 = 4 * 12 + 2;
        const OFFSET: u32 = 84;

        let face_offset = OFFSET + STRIDE * face;

        let nx = get_f32(stl, face_offset + 4 * 0);
        let ny = get_f32(stl, face_offset + 4 * 1);
        let nz = get_f32(stl, face_offset + 4 * 2);
        normals.push(nx);
        normals.push(ny);
        normals.push(nz);
        normals.push(nx);
        normals.push(ny);
        normals.push(nz);
        normals.push(nx);
        normals.push(ny);
        normals.push(nz);

        vertices.push(get_f32(stl, face_offset + 4 * 3));
        vertices.push(get_f32(stl, face_offset + 4 * 4));
        vertices.push(get_f32(stl, face_offset + 4 * 5));

        vertices.push(get_f32(stl, face_offset + 4 * 6));
        vertices.push(get_f32(stl, face_offset + 4 * 7));
        vertices.push(get_f32(stl, face_offset + 4 * 8));

        vertices.push(get_f32(stl, face_offset + 4 * 9));
        vertices.push(get_f32(stl, face_offset + 4 * 10));
        vertices.push(get_f32(stl, face_offset + 4 * 11));

        faces.push((face * 3) as u16);
        faces.push((face * 3 + 1) as u16);
        faces.push((face * 3 + 2) as u16);
    }

    (faces, vertices, normals)
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the normal is pushed into the normals array three times. This
is once for each vertex. </p>
<p>Uploading the normals buffer to the GPU is the same as uploading the 
positions buffer, but the face indices buffer is slightly different. 
It's a bunch of u16's and openGL needs to know what it is. A slight 
modification to the <code>upload_f32_array</code> function results in:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn upload_indices_array(
    gl: &amp;WebGl2RenderingContext,
    indices: Vec&lt;u16&gt;,
) -&gt; Result&lt;WebGlBuffer, QuadError&gt; {
    let index_buffer = gl.create_buffer().ok_or(QuadError::BufferCreationFailed)?;
    gl.bind_buffer(
        WebGl2RenderingContext::ELEMENT_ARRAY_BUFFER,
        Some(&amp;index_buffer),
    );

    let memory_buffer = wasm_bindgen::memory()
        .dyn_into::&lt;js_sys::WebAssembly::Memory&gt;()?
        .buffer();

    let indices_location = indices.as_ptr() as u32 / 2;
    let indices_array = js_sys::Uint16Array::new(&amp;memory_buffer)
        .subarray(indices_location, indices_location + indices.len() as u32);

    gl.buffer_data_with_array_buffer_view(
        WebGl2RenderingContext::ELEMENT_ARRAY_BUFFER,
        &amp;indices_array,
        WebGl2RenderingContext::STATIC_DRAW,
    );

    Ok(index_buffer)
}
<span class="boring">}
</span></code></pre></pre>
<p>And when rendering, we need to activate all these buffers. Remember that
openGL is stateful, so you have to group all the operations on a single
buffer. You can't do all the <code>bind_buffer</code> calls then all the 
<code>enable_vertex_attrib_array</code> calls, you have to deal with each buffer in
turn.</p>
<p>This results in the render function looking like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn render(&amp;mut self, gl: &amp;WebGl2RenderingContext) {
        gl.use_program(Some(&amp;self.program));

        gl.uniform1f(self.uniform_time.as_ref(), self.time);
        gl.uniform2f(
            self.uniform_resolution.as_ref(),
            self.resolution.0 as f32,
            self.resolution.1 as f32,
        );

        bind_2d_texture_to_uniform(
            &amp;gl,
            &amp;self.uniform_image_matcap,
            &amp;self.image_matcap,
            TextureUnit::Unit0,
        );

        gl.enable_vertex_attrib_array(self.attrib_vertex_positions);
        gl.bind_buffer(
            WebGl2RenderingContext::ARRAY_BUFFER,
            Some(&amp;self.position_buffer),
        );
        gl.vertex_attrib_pointer_with_i32(
            self.attrib_vertex_positions,
            3, // num components
            WebGl2RenderingContext::FLOAT,
            false, // normalize
            0,     // stride
            0,     // offset
        );

        gl.enable_vertex_attrib_array(self.attrib_vertex_normals);
        gl.bind_buffer(
            WebGl2RenderingContext::ARRAY_BUFFER,
            Some(&amp;self.normal_buffer),
        );
        gl.vertex_attrib_pointer_with_i32(
            self.attrib_vertex_normals,
            3,     // num components
            WebGl2RenderingContext::FLOAT,
            false, // normalize
            0,     // stride
            0,     // offset
        );

        gl.bind_buffer(
            WebGl2RenderingContext::ELEMENT_ARRAY_BUFFER,
            Some(&amp;self.faces_buffer),
        );

        gl.draw_elements_with_i32(
            WebGl2RenderingContext::TRIANGLES,
            self.num_face_indices as i32,
            WebGl2RenderingContext::UNSIGNED_SHORT,
            0,
        );
    }
<span class="boring">}
</span></code></pre></pre>
<p>I based this off the <code>binding_textures</code> code, so now I did a bunch of
refactoring including things like:</p>
<ul>
<li>Renaming it from <code>quad.rs</code> to <code>geometry.rs</code> and <code>stl.rs</code></li>
<li>Moving shader loading and texture loading external to the geometry handling</li>
</ul>
<h2><a class="header" href="#shaders" id="shaders">Shaders</a></h2>
<p>The shader for 2D simply wrote the vertex position straight to the screen
position. If we simply write the x/y position of the vertices to the screen
position we'll end up with a top view of our object. By multiplying our
vertex positions by a transformation matrix we can rotate the object around:</p>
<pre><code class="language-glsl">#version 300 es

precision mediump float;
in vec4 vert_pos;
in vec4 vert_nor;

uniform vec2 iResolution;
uniform float iTime;

out vec4 screen_pos;
out vec4 screen_nor;


mat4 rot_y(float angle) {
        float c = cos(angle);
        float s = sin(angle);
        return mat4(
                vec4(c, 0.0, s, 0.0),
                vec4(0.0, 1.0, 0.0, 0.0),
                vec4(-s, 0.0, c, 0.0),
                vec4(0.0, 0.0, 0.0, 1.0)
        );
}

mat4 rot_x(float angle) {
        float c = cos(angle);
        float s = sin(angle);
        return mat4(
                vec4(1.0, 0.0, 0.0, 0.0),
                vec4(0.0, c, s, 0.0),
                vec4(0.0, -s, c, 0.0),
                vec4(0.0, 0.0, 0.0, 1.0)
        );
}



void main() {
        
        mat4 pan = rot_y(iTime);
        mat4 tilt = rot_x(sin(iTime));
        
        mat4 mat = tilt * pan;
        
        screen_pos = mat * vert_pos;
        screen_nor = mat * vert_nor;
	
        gl_Position = screen_pos;
        gl_Position.x *= iResolution.y / iResolution.x;
        gl_Position.w = 1.0;
}
</code></pre>
<p>A trick to providing &quot;lighting&quot; for simple scenes like this is to sample
an image using the geometry normals. With an image like this:</p>
<p><img src="stl_viewer_load_stl/./src/resources/matcap.png" alt="A matcap made in blender" /></p>
<p>It provides a &quot;screen space lighting&quot;. As far as I know this is called
a matcap, and is simple and cheap. So the fragment shader simply looks
like:</p>
<pre><code class="language-glsl">#version 300 es

precision mediump float;
in vec4 screen_pos;
in vec4 screen_nor;
out vec4 FragColor;

uniform sampler2D image_matcap;

void main() {
    vec2 matcap_coords = screen_nor.xy * 0.5 + vec2(0.5);
    vec4 matcap = texture(image_matcap, matcap_coords);

    FragColor = matcap;
}
</code></pre>
<p>The final result is:</p>
<p><canvas id="stl_viewer_load_stl"></canvas></p>
<p>You'll noticce there's some clipping on the monkey head ears. This is 
because clip space runs from <code>-1.0</code> to <code>1.0</code> on the <code>z</code> axis and we 
aren't doing any manipulation in the vertex shader to compensate for
this.</p>
<h1><a class="header" href="#stl-viewer-camera-lookaround" id="stl-viewer-camera-lookaround">STL Viewer Camera Lookaround</a></h1>
<p>The user should be able to use the mouse to rotate around the object.
For this we need a more than just a single matrix to use for model
transformation. So we need to introduce mat4's to our rust. Rather than 
reinvent the wheel like I did for <code>swoop</code>, I'll use glam as it seems to 
do what I want.</p>
<p>In fact we need three matrices: The camera transform, the object transform,
and a camera-space-to-clip-space transform. </p>
<p>The struct containing the STL mesh can contain the world_to_model 
matrix, but the camera matrices should be stored elsewhere.</p>
<h1><a class="header" href="#the-camera-matrix" id="the-camera-matrix">The Camera Matrix</a></h1>
<p>We want the camera to rotate around the center of the scene, so it makes
sense to store the camera position as an elevation and azimuth and only
do the conversion when we need the matrix.</p>
<p>So if we store the camera as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Camera {
    pub elevation: f32,
    pub azimuth: f32,
    pub distance: f32,
    pub fov: f32,
    pub aspect: f32,
    pub near: f32,
    pub far: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we can use the functions that glam provides us with to generate
the generate both the camera matrix and to generate the matrix from
the cameras position:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Converts to world_to_camera and camera_to_screen matrices
    pub fn to_matrices(&amp;self) -&gt; (Mat4, Mat4) {
        let sa = f32::sin(self.azimuth);
        let ca = f32::cos(self.azimuth);
        let se = f32::sin(self.elevation);
        let ce = f32::cos(self.elevation);
        let position = Vec3::new(
            self.distance * ca * ce,
            self.distance * sa * ce,
            self.distance * se
        );
        let world_to_camera = Mat4::look_at_rh(
            position,
            Vec3::new(0.0, 0.0, 0.0),
            Vec3::new(0.0, 0.0, 1.0)
        );
        
        let camera_to_screen = Mat4::perspective_rh_gl(
            self.fov,
            self.aspect,
            self.near,
            self.far,
        );
        
        (world_to_camera, camera_to_screen)
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#mouse-look" id="mouse-look">Mouse Look</a></h2>
<p>We now need to set the elevation and azimuth based on the mouse clicking
and dragging. Currently we have all the mouse events going to the same 
callback, but now we need to distinguish mouse down from mouse up and
mouse move. This was just a case of repeating the stuff found in the
binding events page.</p>
<p>Now we can implement the logic that computes how much the user has
moved the mouse each frame the mouse is held down. We do this by storing
the location of the mouse on the previous frame:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct App {
    ...
    click_location: Option&lt;(i32, i32)&gt;,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>When the user is not pressing the mouse the value is <code>None</code>, and when 
the user is pressing the mouse, the value is the screen coordinates of 
the mouse position on the previous frame. Now inside the <code>mouse_move</code> 
callback we can compute the change in position and apply that to the 
cameras orientation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mouse_move(&amp;mut self, event: MouseEvent) {
        const DRAG_SENSITIVITY: f32 = 5.0;
        match self.click_location {
            Some(location) =&gt; {
                
                let new = (event.client_x(), event.client_y());
                let delta = (location.0 - new.0, location.1 - new.1);
                self.click_location = Some(new);
                
                let percentage_x = (delta.0 as f32) / (self.resolution.0 as f32) * DRAG_SENSITIVITY;
                let percentage_y = (delta.1 as f32) / (self.resolution.0 as f32) * DRAG_SENSITIVITY;
                
                self.camera.azimuth += percentage_x;
                self.camera.elevation -= percentage_y;
                self.camera.elevation = f32::min(f32::max(self.camera.elevation, -1.4), 1.4);
                
            }
            None =&gt; {
            }
        }
    }
    pub fn mouse_down(&amp;mut self, event: MouseEvent) {
        self.click_location = Some((event.client_x(), event.client_y()));
    }
    pub fn mouse_up(&amp;mut self, _event: MouseEvent) {
        self.click_location = None;
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#updating-the-vertex-shader" id="updating-the-vertex-shader">Updating the Vertex Shader</a></h2>
<p>We have all three matrices, and can pass them into the vertex shader,
but what then?</p>
<pre><code class="language-glsl">#version 300 es

precision mediump float;
in vec3 vert_pos;
in vec3 vert_nor;

out vec3 screen_pos;
out vec3 screen_nor;

uniform mat4 world_to_camera;
uniform mat4 world_to_model;
uniform mat4 camera_to_screen;

void main() {
    mat4 model_to_world = inverse(world_to_model);
    mat4 model_to_camera = world_to_camera * model_to_world;
    mat4 model_to_screen = camera_to_screen * model_to_camera;
    
    vec4 pos = vec4(vert_pos, 1.0);
    vec4 nor = vec4(vert_nor, 0.0);

    pos = model_to_screen * pos;
    nor = model_to_camera * nor;        
    
    screen_pos = pos.xyz / pos.w;
    screen_nor = nor.xyz;

    gl_Position.xyz = screen_pos;
    gl_Position.w = 1.0;
}
</code></pre>
<p>We can test this transforms by rendering the same mesh at two different
locations and checking that the camera moves around as we would expect:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let (world_to_camera, camera_to_screen) = self.camera.to_matrices();
        self.shader_stl.setup(&amp;self.gl, world_to_camera, camera_to_screen);
        
        self.stl.world_to_model = Mat4::from_translation(Vec3::new(0.0, -25.0, 0.0));
        self.stl.render(&amp;self.gl, &amp;self.shader_stl);
        self.stl.world_to_model = Mat4::from_translation(Vec3::new(0.0, 25.0, 0.0));
        self.stl.render(&amp;self.gl, &amp;self.shader_stl);
<span class="boring">}
</span></code></pre></pre>
<p>And the result is:</p>
<p><canvas id="stl_viewer_camera_lookaround"></canvas></p>
<h1><a class="header" href="#background-and-appearance" id="background-and-appearance">Background and Appearance</a></h1>
<p>The background is black - pretty boring. And although the matcap looks OK,
it would be nice to have something a bit fancier. </p>
<h1><a class="header" href="#full-screen-quad" id="full-screen-quad">Full Screen Quad</a></h1>
<p>What is a background? Well, it's always behind everything in the scene, 
and it should have some sort of shading so that the user can see which 
way they are facing. Because it has to cover the entiere screen we can 
either use a box surrounding the scene (ie cubemap) or we can use a 
single full screen quad.</p>
<p>Fortunately we already know how to full screen quads as we've been 
doing them since the beginning. The only difference is that in the 
vertex shader we need to compute the world space coordinates of the 
vertices so that it can be textured, and we need to force the Z 
distance to be behind everything.</p>
<pre><code class="language-glsl">#version 300 es
precision mediump float;

in vec2 vert_pos; // In Screen Space
out vec3 world_pos;

uniform mat4 world_to_camera;
uniform mat4 camera_to_screen;

void main() {
    
    mat4 camera_to_world = inverse(world_to_camera);
    mat4 screen_to_camera = inverse(camera_to_screen);
    mat4 screen_to_world = camera_to_world * screen_to_camera;
    
    vec4 world_pos_tmp = screen_to_world * vec4(vert_pos, 1.0, 1.0);
    world_pos = world_pos_tmp.xyz;

    gl_Position.xy = vert_pos.xy;
    gl_Position.z = 0.99999;
    gl_Position.w = 1.0;
}
</code></pre>
<h1><a class="header" href="#texturing-the-full-screen-quad" id="texturing-the-full-screen-quad">Texturing the full screen quad</a></h1>
<p>Now we have the world position of each corner, and we need to find some
way to represent the world. Blender can render out equirectangular maps,
so we may as well use one of those. Just to be fancy, we can use encode
the brightness of the image in the alpha channel to allow encoding
brightness's higher than <code>1</code>. </p>
<p>That all works out to:</p>
<pre><code class="language-glsl">#version 300 es
precision mediump float;

in vec3 world_pos;
out vec4 FragColor;

uniform sampler2D image_matcap;


vec3 sample_background(vec3 pos, float mip) {
    vec2 coords = vec2(
        atan(pos.y, pos.x) / 3.14159,
        sin(pos.z)
    );
    coords = coords * 0.5 + 0.5;
    
    vec4 raw = textureLod(image_matcap, coords, mip);
    float luminance = pow(((1.0 / raw.a) - 1.0), 1.0 / 2.2);
    
    return raw.rgb * luminance;
}


void main() {
    vec3 matcap = sample_background(world_pos, 2.0);
    FragColor.rgb = matcap * 0.5;
    FragColor.a = 1.0;
}
</code></pre>
<h1><a class="header" href="#cooler-model-lighting" id="cooler-model-lighting">Cooler Model Lighting</a></h1>
<p>It would be cool if we could use the same image to light the geometry.
How can we do this? Well, we need to approximate the diffuse lighting
and perhaps some specular as well. Diffuse lighting can be approximated
by sampling in the direction of the surface normal (perhaps from a smaller
mip to emulate a surface roughness). Specular highlights are caused by
reflections, so we can use the GLSL reflect function to find what direction
to sample in.</p>
<p>From there, we can fiddle with the strength and blending of these lighting
values with the surface color to achieve our result.</p>
<p>Using the same <code>sample_background</code> function as per before:</p>
<pre><code class="language-glsl">void main() {
    vec3 diffuse = sample_background(world_nor, 3.0);
    
    vec3 reflect = reflect(vec3(0.0, 0.0, -1.0), screen_nor);
    vec4 reflect_world = (camera_to_world * vec4(reflect, 0.0));
    vec3 reflection = sample_background(reflect_world.xyz, 4.0);
    
    float fresnel = 1.0 - dot(screen_nor, vec3(0.0, 0.0, 1.0));
    
    vec3 out_col = color;
    out_col = out_col * diffuse;
    out_col += reflection * fresnel * 0.5;
    out_col *= 1.0 - fresnel * 0.5;
    
    FragColor.rgb = out_col;
    FragColor.a = 1.0;
}
</code></pre>
<p>And our final canvas is:</p>
<p><canvas id="stl_viewer_background"></canvas></p>
<p>Because I was developing this on my laptop away from a power socket,
I also changed the rendering to only render periodically, but to force
updates when the camera is moving:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn animation_frame(&amp;mut self) {
        self.check_resize();
        let now = window().unwrap().performance().unwrap().now();
        let time = (now / 1000.0) as f32;
        
        
        let time_since_render = time - self.last_render_time;
        if time_since_render &gt; 0.2 {
            self.dirty = true;
        }
        
        if self.dirty {
            self.render();
            self.dirty = false;
            self.last_render_time = time;
        }
    }
    
    ...
    
    // For example:
    pub fn mouse_down(&amp;mut self, event: MouseEvent) {
        self.click_location = Some((event.client_x(), event.client_y()));
        self.dirty = true;
    }
    ...

<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="custom.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
